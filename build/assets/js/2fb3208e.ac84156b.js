"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[129],{3421:(n,i,e)=>{e.r(i),e.d(i,{assets:()=>s,contentTitle:()=>l,default:()=>m,frontMatter:()=>r,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"module-2-digital-twin/urdf-validation","title":"URDF Model Creation and Validation","description":"Creating accurate URDF models is fundamental to successful digital twin implementation. This section covers best practices for creating URDF models and validating them for use in simulation environments.","source":"@site/docs/module-2-digital-twin/urdf-validation.md","sourceDirName":"module-2-digital-twin","slug":"/module-2-digital-twin/urdf-validation","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/module-2-digital-twin/urdf-validation","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Unity Visualization","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/module-2-digital-twin/unity-visualization"},"next":{"title":"Module 3 AI Perception","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/module-3-ai-perception/"}}');var a=e(4848),t=e(8453);const r={},l="URDF Model Creation and Validation",s={},c=[{value:"URDF Model Best Practices",id:"urdf-model-best-practices",level:2},{value:"1. Proper Kinematic Structure",id:"1-proper-kinematic-structure",level:3},{value:"2. Proper Inertial Properties",id:"2-proper-inertial-properties",level:3},{value:"Validation Techniques",id:"validation-techniques",level:2},{value:"1. URDF Validation Tools",id:"1-urdf-validation-tools",level:3},{value:"Check URDF",id:"check-urdf",level:4},{value:"View URDF",id:"view-urdf",level:4},{value:"2. Simulation Validation",id:"2-simulation-validation",level:3},{value:"Gazebo Validation",id:"gazebo-validation",level:4},{value:"3. Kinematic Validation",id:"3-kinematic-validation",level:3},{value:"Forward Kinematics",id:"forward-kinematics",level:4},{value:"Advanced Validation Examples",id:"advanced-validation-examples",level:2},{value:"1. Collision Detection Validation",id:"1-collision-detection-validation",level:3},{value:"2. Center of Mass Validation",id:"2-center-of-mass-validation",level:3},{value:"3. Dynamic Validation",id:"3-dynamic-validation",level:3},{value:"4. Range of Motion Validation",id:"4-range-of-motion-validation",level:3},{value:"Common Validation Issues and Solutions",id:"common-validation-issues-and-solutions",level:2},{value:"1. Floating Point Errors",id:"1-floating-point-errors",level:3},{value:"2. Mass Distribution Issues",id:"2-mass-distribution-issues",level:3},{value:"3. Joint Limit Problems",id:"3-joint-limit-problems",level:3},{value:"4. Collision Issues",id:"4-collision-issues",level:3},{value:"Automated Validation Script",id:"automated-validation-script",level:2},{value:"Best Practices Summary",id:"best-practices-summary",level:2},{value:"Exercise",id:"exercise",level:2}];function d(n){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.header,{children:(0,a.jsx)(i.h1,{id:"urdf-model-creation-and-validation",children:"URDF Model Creation and Validation"})}),"\n",(0,a.jsx)(i.p,{children:"Creating accurate URDF models is fundamental to successful digital twin implementation. This section covers best practices for creating URDF models and validating them for use in simulation environments."}),"\n",(0,a.jsx)(i.h2,{id:"urdf-model-best-practices",children:"URDF Model Best Practices"}),"\n",(0,a.jsx)(i.h3,{id:"1-proper-kinematic-structure",children:"1. Proper Kinematic Structure"}),"\n",(0,a.jsx)(i.p,{children:"A well-structured URDF model should have a clear kinematic chain:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="humanoid_with_proper_structure" xmlns:xacro="http://www.ros.org/wiki/xacro">\n  \x3c!-- Base link (required - no geometry needed for simple base) --\x3e\n  <link name="base_link">\n    <visual>\n      <origin xyz="0 0 0.25" rpy="0 0 0"/>\n      <geometry>\n        <box size="0.3 0.3 0.5"/>\n      </geometry>\n      <material name="light_gray">\n        <color rgba="0.7 0.7 0.7 1"/>\n      </material>\n    </visual>\n    <collision>\n      <origin xyz="0 0 0.25" rpy="0 0 0"/>\n      <geometry>\n        <box size="0.3 0.3 0.5"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="10.0"/>\n      <origin xyz="0 0 0.25" rpy="0 0 0"/>\n      <inertia ixx="0.2" ixy="0.0" ixz="0.0" iyy="0.2" iyz="0.0" izz="0.1"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Head --\x3e\n  <joint name="neck_joint" type="revolute">\n    <parent link="base_link"/>\n    <child link="head_link"/>\n    <origin xyz="0 0 0.5" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="-0.5" upper="0.5" effort="10" velocity="2"/>\n    <dynamics damping="0.5" friction="0.1"/>\n  </joint>\n\n  <link name="head_link">\n    <visual>\n      <geometry>\n        <sphere radius="0.1"/>\n      </geometry>\n      <material name="skin">\n        <color rgba="0.8 0.6 0.4 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <sphere radius="0.1"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="2.0"/>\n      <inertia ixx="0.004" ixy="0.0" ixz="0.0" iyy="0.004" iyz="0.0" izz="0.004"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Left Arm (using Xacro macros for consistency) --\x3e\n  <xacro:macro name="simple_arm" params="side parent xyz rpy joint_limits_lower joint_limits_upper">\n    \x3c!-- Shoulder --\x3e\n    <joint name="${side}_shoulder_pitch_joint" type="revolute">\n      <parent link="${parent}"/>\n      <child link="${side}_shoulder_link"/>\n      <origin xyz="${xyz}" rpy="${rpy}"/>\n      <axis xyz="0 1 0"/>\n      <limit lower="${joint_limits_lower}" upper="${joint_limits_upper}" effort="15" velocity="2"/>\n      <dynamics damping="0.5" friction="0.1"/>\n    </joint>\n\n    <link name="${side}_shoulder_link">\n      <visual>\n        <geometry>\n          <box size="0.08 0.08 0.1"/>\n        </geometry>\n        <material name="dark_gray">\n          <color rgba="0.3 0.3 0.3 1"/>\n        </material>\n      </visual>\n      <collision>\n        <geometry>\n          <box size="0.08 0.08 0.1"/>\n        </geometry>\n      </collision>\n      <inertial>\n        <mass value="1.0"/>\n        <inertia ixx="0.001" ixy="0.0" ixz="0.0" iyy="0.001" iyz="0.0" izz="0.001"/>\n      </inertial>\n    </link>\n\n    <joint name="${side}_shoulder_yaw_joint" type="revolute">\n      <parent link="${side}_shoulder_link"/>\n      <child link="${side}_upper_arm_link"/>\n      <origin xyz="0 0 -0.1" rpy="0 0 0"/>\n      <axis xyz="1 0 0"/>\n      <limit lower="-1.57" upper="1.57" effort="15" velocity="2"/>\n      <dynamics damping="0.5" friction="0.1"/>\n    </joint>\n\n    <link name="${side}_upper_arm_link">\n      <visual>\n        <geometry>\n          <cylinder length="0.3" radius="0.05"/>\n        </geometry>\n        <material name="dark_gray"/>\n      </visual>\n      <collision>\n        <geometry>\n          <cylinder length="0.3" radius="0.05"/>\n        </geometry>\n      </collision>\n      <inertial>\n        <mass value="1.5"/>\n        <inertia ixx="0.005" ixy="0.0" ixz="0.0" iyy="0.005" iyz="0.0" izz="0.0005"/>\n      </inertial>\n    </link>\n\n    <joint name="${side}_elbow_joint" type="revolute">\n      <parent link="${side}_upper_arm_link"/>\n      <child link="${side}_lower_arm_link"/>\n      <origin xyz="0 0 -0.3" rpy="0 0 0"/>\n      <axis xyz="0 1 0"/>\n      <limit lower="-0.1" upper="2.0" effort="10" velocity="2"/>\n      <dynamics damping="0.3" friction="0.1"/>\n    </joint>\n\n    <link name="${side}_lower_arm_link">\n      <visual>\n        <geometry>\n          <cylinder length="0.25" radius="0.04"/>\n        </geometry>\n        <material name="dark_gray"/>\n      </visual>\n      <collision>\n        <geometry>\n          <cylinder length="0.25" radius="0.04"/>\n        </geometry>\n      </collision>\n      <inertial>\n        <mass value="1.0"/>\n        <inertia ixx="0.003" ixy="0.0" ixz="0.0" iyy="0.003" iyz="0.0" izz="0.0003"/>\n      </inertial>\n    </link>\n  </xacro:macro>\n\n  \x3c!-- Use the macro for both arms --\x3e\n  <xacro:simple_arm\n    side="left"\n    parent="base_link"\n    xyz="0.15 0 0.2"\n    rpy="0 0 0"\n    joint_limits_lower="-1.57"\n    joint_limits_upper="1.57"/>\n\n  <xacro:simple_arm\n    side="right"\n    parent="base_link"\n    xyz="-0.15 0 0.2"\n    rpy="0 0 0"\n    joint_limits_lower="-1.57"\n    joint_limits_upper="1.57"/>\n</robot>\n'})}),"\n",(0,a.jsx)(i.h3,{id:"2-proper-inertial-properties",children:"2. Proper Inertial Properties"}),"\n",(0,a.jsx)(i.p,{children:"Accurate inertial properties are crucial for realistic physics simulation:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-xml",children:'\x3c!-- For a solid box --\x3e\n<inertial>\n  <mass value="5.0"/>\n  <origin xyz="0 0 0"/>\n  <inertia\n    ixx="0.0833333"  \x3c!-- m*(h\xb2 + d\xb2)/12 --\x3e\n    ixy="0.0"\n    ixz="0.0"\n    iyy="0.0833333"  \x3c!-- m*(w\xb2 + d\xb2)/12 --\x3e\n    iyz="0.0"\n    izz="0.0833333"/> \x3c!-- m*(w\xb2 + h\xb2)/12 --\x3e\n</inertial>\n\n\x3c!-- For a solid cylinder along Z-axis --\x3e\n<inertial>\n  <mass value="1.0"/>\n  <origin xyz="0 0 0"/>\n  <inertia\n    ixx="0.0052083"  \x3c!-- m*(3*r\xb2 + h\xb2)/12 --\x3e\n    ixy="0.0"\n    ixz="0.0"\n    iyy="0.0052083"\n    iyz="0.0"\n    izz="0.0025"/>    \x3c!-- m*r\xb2/2 --\x3e\n</inertial>\n\n\x3c!-- For a solid sphere --\x3e\n<inertial>\n  <mass value="2.0"/>\n  <origin xyz="0 0 0"/>\n  <inertia\n    ixx="0.02"       \x3c!-- 2*m*r\xb2/5 --\x3e\n    ixy="0.0"\n    ixz="0.0"\n    iyy="0.02"\n    iyz="0.0"\n    izz="0.02"/>\n</inertial>\n'})}),"\n",(0,a.jsx)(i.h2,{id:"validation-techniques",children:"Validation Techniques"}),"\n",(0,a.jsx)(i.h3,{id:"1-urdf-validation-tools",children:"1. URDF Validation Tools"}),"\n",(0,a.jsx)(i.h4,{id:"check-urdf",children:"Check URDF"}),"\n",(0,a.jsxs)(i.p,{children:["Use the ",(0,a.jsx)(i.code,{children:"check_urdf"})," command to validate your URDF:"]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-bash",children:"# Install the tool if not already installed\nsudo apt install ros-humble-urdfdom-py\n\n# Check your URDF file\ncheck_urdf /path/to/your/robot.urdf\n"})}),"\n",(0,a.jsx)(i.h4,{id:"view-urdf",children:"View URDF"}),"\n",(0,a.jsx)(i.p,{children:"Visualize your robot structure:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-bash",children:"# Install visualization tools\nsudo apt install ros-humble-joint-state-publisher-gui\n\n# View the robot\nurdf_to_graphiz /path/to/your/robot.urdf\n# This creates .gv files that can be viewed with Graphviz\n"})}),"\n",(0,a.jsx)(i.h3,{id:"2-simulation-validation",children:"2. Simulation Validation"}),"\n",(0,a.jsx)(i.h4,{id:"gazebo-validation",children:"Gazebo Validation"}),"\n",(0,a.jsx)(i.p,{children:"Test your URDF in Gazebo:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-xml",children:'\x3c!-- Add Gazebo-specific tags for simulation --\x3e\n<gazebo reference="base_link">\n  <material>Gazebo/Blue</material>\n  <mu1>0.2</mu1>\n  <mu2>0.2</mu2>\n  <kp>1000000.0</kp>  \x3c!-- Contact stiffness --\x3e\n  <kd>100.0</kd>      \x3c!-- Contact damping --\x3e\n</gazebo>\n\n\x3c!-- Add transmission for ROS control --\x3e\n<xacro:macro name="transmission_block" params="joint_name">\n  <transmission name="${joint_name}_trans">\n    <type>transmission_interface/SimpleTransmission</type>\n    <joint name="${joint_name}">\n      <hardwareInterface>hardware_interface/EffortJointInterface</hardwareInterface>\n    </joint>\n    <actuator name="${joint_name}_motor">\n      <hardwareInterface>hardware_interface/EffortJointInterface</hardwareInterface>\n      <mechanicalReduction>1</mechanicalReduction>\n    </actuator>\n  </transmission>\n</xacro:macro>\n'})}),"\n",(0,a.jsx)(i.h3,{id:"3-kinematic-validation",children:"3. Kinematic Validation"}),"\n",(0,a.jsx)(i.h4,{id:"forward-kinematics",children:"Forward Kinematics"}),"\n",(0,a.jsx)(i.p,{children:"Validate that your kinematic chain works correctly:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-python",children:"#!/usr/bin/env python3\nimport rospy\nimport tf2_ros\nfrom urdf_parser_py.urdf import URDF\nfrom pykdl_utils.kdl_kinematics import KDLKinematics\n\ndef validate_kinematics():\n    # Load robot description\n    robot = URDF.from_xml_string(rospy.get_param('robot_description'))\n\n    # Create kinematic chain\n    kdl_kin = KDLKinematics(robot, 'base_link', 'left_hand_link')\n\n    # Test joint positions\n    q = [0.0, 0.0, 0.0, 0.0, 0.0]  # joint angles\n    pose = kdl_kin.forward(q)\n    print(f\"End effector pose: {pose}\")\n\n    # Test inverse kinematics\n    q_ik = kdl_kin.inverse(pose)\n    print(f\"IK solution: {q_ik}\")\n\nif __name__ == '__main__':\n    rospy.init_node('kinematic_validator')\n    validate_kinematics()\n"})}),"\n",(0,a.jsx)(i.h2,{id:"advanced-validation-examples",children:"Advanced Validation Examples"}),"\n",(0,a.jsx)(i.h3,{id:"1-collision-detection-validation",children:"1. Collision Detection Validation"}),"\n",(0,a.jsx)(i.p,{children:"Ensure no self-collision in common poses:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-xml",children:'\x3c!-- Add self-collision checking parameters --\x3e\n<robot name="collision_test_robot">\n  \x3c!-- Define collision pairs to ignore (if needed) --\x3e\n  <gazebo>\n    <self_collide>false</self_collide>  \x3c!-- Only for specific testing --\x3e\n  </gazebo>\n\n  \x3c!-- Or be more specific with collision filtering --\x3e\n  <gazebo reference="link1">\n    <collision>\n      <surface>\n        <contact>\n          <collide_without_contact>false</collide_without_contact>\n        </contact>\n      </surface>\n    </collision>\n  </gazebo>\n</robot>\n'})}),"\n",(0,a.jsx)(i.h3,{id:"2-center-of-mass-validation",children:"2. Center of Mass Validation"}),"\n",(0,a.jsx)(i.p,{children:"Calculate and verify center of mass:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-python",children:"#!/usr/bin/env python3\nimport rospy\nfrom urdf_parser_py.urdf import URDF\nimport numpy as np\n\ndef calculate_total_com():\n    robot = URDF.from_xml_string(rospy.get_param('robot_description'))\n\n    total_mass = 0.0\n    weighted_com = np.array([0.0, 0.0, 0.0])\n\n    for link in robot.links:\n        if link.inertial and link.inertial.mass:\n            mass = link.inertial.mass\n            com = np.array([\n                link.inertial.origin.xyz[0],\n                link.inertial.origin.xyz[1],\n                link.inertial.origin.xyz[2]\n            ])\n\n            total_mass += mass\n            weighted_com += mass * com\n\n    overall_com = weighted_com / total_mass if total_mass > 0 else np.array([0, 0, 0])\n    print(f\"Overall center of mass: {overall_com}\")\n    print(f\"Total mass: {total_mass}\")\n\nif __name__ == '__main__':\n    rospy.init_node('com_calculator')\n    calculate_total_com()\n"})}),"\n",(0,a.jsx)(i.h3,{id:"3-dynamic-validation",children:"3. Dynamic Validation"}),"\n",(0,a.jsx)(i.p,{children:"Test dynamic properties in simulation:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-yaml",children:"# controllers.yaml for testing\ncontroller_manager:\n  ros__parameters:\n    update_rate: 100\n\n    joint_state_broadcaster:\n      type: joint_state_broadcaster/JointStateBroadcaster\n\n    left_arm_controller:\n      type: position_controllers/JointGroupPositionController\n      joints:\n        - left_shoulder_pitch_joint\n        - left_shoulder_yaw_joint\n        - left_elbow_joint\n\n    right_arm_controller:\n      type: position_controllers/JointGroupPositionController\n      joints:\n        - right_shoulder_pitch_joint\n        - right_shoulder_yaw_joint\n        - right_elbow_joint\n"})}),"\n",(0,a.jsx)(i.h3,{id:"4-range-of-motion-validation",children:"4. Range of Motion Validation"}),"\n",(0,a.jsx)(i.p,{children:"Test joint limits and workspace:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-python",children:"#!/usr/bin/env python3\nimport rospy\nfrom sensor_msgs.msg import JointState\nimport numpy as np\n\nclass JointRangeValidator:\n    def __init__(self):\n        self.joint_limits = {\n            'left_shoulder_pitch_joint': (-1.57, 1.57),\n            'left_shoulder_yaw_joint': (-1.57, 1.57),\n            'left_elbow_joint': (-0.1, 2.0)\n        }\n\n        rospy.Subscriber('/joint_states', JointState, self.joint_callback)\n\n    def joint_callback(self, msg):\n        for i, name in enumerate(msg.name):\n            if name in self.joint_limits:\n                pos = msg.position[i]\n                min_pos, max_pos = self.joint_limits[name]\n\n                if pos < min_pos or pos > max_pos:\n                    rospy.logwarn(f\"Joint {name} out of range: {pos} (limits: {min_pos}, {max_pos})\")\n                elif abs(pos - min_pos) < 0.1 or abs(pos - max_pos) < 0.1:\n                    rospy.loginfo(f\"Joint {name} approaching limit: {pos}\")\n\nif __name__ == '__main__':\n    rospy.init_node('joint_range_validator')\n    validator = JointRangeValidator()\n    rospy.spin()\n"})}),"\n",(0,a.jsx)(i.h2,{id:"common-validation-issues-and-solutions",children:"Common Validation Issues and Solutions"}),"\n",(0,a.jsx)(i.h3,{id:"1-floating-point-errors",children:"1. Floating Point Errors"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Use appropriate precision in URDF values"}),"\n",(0,a.jsx)(i.li,{children:"Validate with tolerance checks in code"}),"\n"]}),"\n",(0,a.jsx)(i.h3,{id:"2-mass-distribution-issues",children:"2. Mass Distribution Issues"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Ensure center of mass is reasonable"}),"\n",(0,a.jsx)(i.li,{children:"Verify moments of inertia are positive and realistic"}),"\n"]}),"\n",(0,a.jsx)(i.h3,{id:"3-joint-limit-problems",children:"3. Joint Limit Problems"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Test extreme positions in simulation"}),"\n",(0,a.jsx)(i.li,{children:"Validate with physical constraints"}),"\n"]}),"\n",(0,a.jsx)(i.h3,{id:"4-collision-issues",children:"4. Collision Issues"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Check for interpenetration at default positions"}),"\n",(0,a.jsx)(i.li,{children:"Test various poses for self-collision"}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"automated-validation-script",children:"Automated Validation Script"}),"\n",(0,a.jsx)(i.p,{children:"Create a comprehensive validation script:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-bash",children:'#!/bin/bash\n# validate_robot.sh\n\nURDF_FILE=$1\nif [ -z "$URDF_FILE" ]; then\n    echo "Usage: $0 <urdf_file>"\n    exit 1\nfi\n\necho "Validating $URDF_FILE..."\n\n# Check if file exists\nif [ ! -f "$URDF_FILE" ]; then\n    echo "Error: File $URDF_FILE does not exist"\n    exit 1\nfi\n\n# Validate URDF structure\necho "Checking URDF structure..."\ncheck_urdf "$URDF_FILE" 2>&1 | tee urdf_check.log\nif [ $? -ne 0 ]; then\n    echo "URDF validation failed!"\n    exit 1\nfi\n\n# Check for common issues\necho "Checking for common issues..."\n\n# Check for duplicate names\nDUPLICATE_LINKS=$(grep -oP \'(?<=<link name=")[^"]*\' "$URDF_FILE" | sort | uniq -d)\nif [ ! -z "$DUPLICATE_LINKS" ]; then\n    echo "Warning: Duplicate link names found: $DUPLICATE_LINKS"\nfi\n\nDUPLICATE_JOINTS=$(grep -oP \'(?<=<joint name=")[^"]*\' "$URDF_FILE" | sort | uniq -d)\nif [ ! -z "$DUPLICATE_JOINTS" ]; then\n    echo "Warning: Duplicate joint names found: $DUPLICATE_JOINTS"\nfi\n\n# Check for missing inertial properties\nMISSING_INERTIAL=$(grep -B 10 \'mass\' "$URDF_FILE" | grep -E \'^<link name=\' | wc -l)\nTOTAL_LINKS=$(grep -c \'<link name=\' "$URDF_FILE")\nif [ $TOTAL_LINKS -ne $MISSING_INERTIAL ]; then\n    echo "Warning: Some links may be missing inertial properties"\nfi\n\necho "Validation complete. Check urdf_check.log for details."\n'})}),"\n",(0,a.jsx)(i.h2,{id:"best-practices-summary",children:"Best Practices Summary"}),"\n",(0,a.jsxs)(i.ol,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Always validate"})," URDF files before simulation"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Use consistent units"})," (SI units: meters, kilograms, seconds)"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Test kinematic chains"})," with forward and inverse kinematics"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Verify inertial properties"})," with realistic values"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Test collision detection"})," with various robot poses"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Check joint limits"})," against physical constraints"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Validate center of mass"})," for stability"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"Use Xacro macros"})," for complex, repetitive structures"]}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"exercise",children:"Exercise"}),"\n",(0,a.jsx)(i.p,{children:"Create a complete humanoid robot URDF model with:"}),"\n",(0,a.jsxs)(i.ol,{children:["\n",(0,a.jsx)(i.li,{children:"Proper kinematic structure (tree topology)"}),"\n",(0,a.jsx)(i.li,{children:"Accurate inertial properties for all links"}),"\n",(0,a.jsx)(i.li,{children:"Appropriate joint limits based on human anatomy"}),"\n",(0,a.jsx)(i.li,{children:"Validation tests to ensure the model is physically realistic"}),"\n",(0,a.jsx)(i.li,{children:"Integration with both Gazebo and Unity simulation environments"}),"\n"]}),"\n",(0,a.jsx)(i.p,{children:"Validate your model using the tools and techniques described in this section, ensuring it behaves realistically in simulation."})]})}function m(n={}){const{wrapper:i}={...(0,t.R)(),...n.components};return i?(0,a.jsx)(i,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}},8453:(n,i,e)=>{e.d(i,{R:()=>r,x:()=>l});var o=e(6540);const a={},t=o.createContext(a);function r(n){const i=o.useContext(t);return o.useMemo(function(){return"function"==typeof n?n(i):{...i,...n}},[i,n])}function l(n){let i;return i=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:r(n.components),o.createElement(t.Provider,{value:i},n.children)}}}]);