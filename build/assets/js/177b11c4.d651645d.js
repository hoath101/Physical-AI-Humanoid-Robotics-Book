"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[699],{3154:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>a,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"module-4-vla/humanoid-locomotion-control","title":"Humanoid Locomotion and Control","description":"Humanoid locomotion represents one of the most challenging problems in robotics, requiring sophisticated control systems to achieve stable, efficient, and human-like movement. This section covers the principles and implementation of humanoid locomotion using Isaac Sim and Isaac ROS.","source":"@site/docs/module-4-vla/humanoid-locomotion-control.md","sourceDirName":"module-4-vla","slug":"/module-4-vla/humanoid-locomotion-control","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/module-4-vla/humanoid-locomotion-control","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Summary: Physical AI & Humanoid Robotics Book","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/module-4-vla/summary"},"next":{"title":"Isaac ROS Integration","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/module-4-vla/isaac-ros-integration"}}');var i=t(4848),r=t(8453);const a={},s="Humanoid Locomotion and Control",l={},c=[{value:"Introduction to Humanoid Locomotion",id:"introduction-to-humanoid-locomotion",level:2},{value:"Key Challenges in Humanoid Locomotion",id:"key-challenges-in-humanoid-locomotion",level:3},{value:"Types of Humanoid Gait",id:"types-of-humanoid-gait",level:3},{value:"Center of Mass (CoM) Control",id:"center-of-mass-com-control",level:2},{value:"Zero Moment Point (ZMP) Theory",id:"zero-moment-point-zmp-theory",level:3},{value:"Center of Pressure (CoP) vs ZMP",id:"center-of-pressure-cop-vs-zmp",level:3},{value:"Walking Pattern Generation",id:"walking-pattern-generation",level:2},{value:"Preview Control Method",id:"preview-control-method",level:3},{value:"Linear Inverted Pendulum Model (LIPM)",id:"linear-inverted-pendulum-model-lipm",level:3},{value:"Isaac ROS Humanoid Control Integration",id:"isaac-ros-humanoid-control-integration",level:2},{value:"Isaac ROS Control Packages",id:"isaac-ros-control-packages",level:3},{value:"Humanoid Balance Controller",id:"humanoid-balance-controller",level:3},{value:"Isaac Sim Humanoid Simulation",id:"isaac-sim-humanoid-simulation",level:2},{value:"Creating Humanoid Robots in Isaac Sim",id:"creating-humanoid-robots-in-isaac-sim",level:3},{value:"Gait Planning and Execution",id:"gait-planning-and-execution",level:2},{value:"Walking Pattern Generator",id:"walking-pattern-generator",level:3},{value:"ROS 2 Integration for Humanoid Control",id:"ros-2-integration-for-humanoid-control",level:2},{value:"Humanoid Controller Manager",id:"humanoid-controller-manager",level:3},{value:"Advanced Locomotion Patterns",id:"advanced-locomotion-patterns",level:2},{value:"Different Gait Types",id:"different-gait-types",level:3},{value:"Balance Recovery Behaviors",id:"balance-recovery-behaviors",level:2},{value:"Fall Prevention and Recovery",id:"fall-prevention-and-recovery",level:3},{value:"Performance Evaluation",id:"performance-evaluation",level:2},{value:"Metrics for Humanoid Locomotion",id:"metrics-for-humanoid-locomotion",level:3},{value:"Troubleshooting Common Issues",id:"troubleshooting-common-issues",level:2},{value:"1. Instability and Falls",id:"1-instability-and-falls",level:3},{value:"2. Joint Limit Violations",id:"2-joint-limit-violations",level:3},{value:"3. ZMP Outside Support Polygon",id:"3-zmp-outside-support-polygon",level:3},{value:"4. Phase Synchronization Issues",id:"4-phase-synchronization-issues",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Gradual Complexity Increase",id:"1-gradual-complexity-increase",level:3},{value:"2. Safety First Approach",id:"2-safety-first-approach",level:3},{value:"3. Parameter Tuning",id:"3-parameter-tuning",level:3},{value:"4. Sensor Fusion",id:"4-sensor-fusion",level:3},{value:"Exercise",id:"exercise",level:2}];function _(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"humanoid-locomotion-and-control",children:"Humanoid Locomotion and Control"})}),"\n",(0,i.jsx)(e.p,{children:"Humanoid locomotion represents one of the most challenging problems in robotics, requiring sophisticated control systems to achieve stable, efficient, and human-like movement. This section covers the principles and implementation of humanoid locomotion using Isaac Sim and Isaac ROS."}),"\n",(0,i.jsx)(e.h2,{id:"introduction-to-humanoid-locomotion",children:"Introduction to Humanoid Locomotion"}),"\n",(0,i.jsx)(e.p,{children:"Humanoid locomotion involves the complex control of multi-degree-of-freedom systems to achieve stable movement patterns similar to human walking. Unlike wheeled robots, humanoid robots must manage balance, foot placement, and dynamic stability simultaneously."}),"\n",(0,i.jsx)(e.h3,{id:"key-challenges-in-humanoid-locomotion",children:"Key Challenges in Humanoid Locomotion"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Balance Control"}),": Maintaining center of mass within support polygon"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Step Planning"}),": Determining optimal foot placement"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Gait Generation"}),": Creating stable walking patterns"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Terrain Adaptation"}),": Adjusting to different surfaces and obstacles"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Dynamic Stability"}),": Managing momentum during movement"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"types-of-humanoid-gait",children:"Types of Humanoid Gait"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Static Gait"}),": Center of mass always within support polygon"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Dynamic Gait"}),": Uses momentum to maintain balance"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Passive Dynamic"}),": Exploits mechanical dynamics for efficient walking"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Adaptive Gait"}),": Adjusts to terrain and disturbances in real-time"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"center-of-mass-com-control",children:"Center of Mass (CoM) Control"}),"\n",(0,i.jsx)(e.h3,{id:"zero-moment-point-zmp-theory",children:"Zero Moment Point (ZMP) Theory"}),"\n",(0,i.jsx)(e.p,{children:"The Zero Moment Point is a critical concept in humanoid locomotion:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"ZMP = (\u03a3(mi * (xi * g - x''i * mi)) / \u03a3(mi * g - z''i * mi), \u03a3(mi * (yi * g - y''i * mi)) / \u03a3(mi * g - z''i * mi))\n"})}),"\n",(0,i.jsx)(e.p,{children:"Where:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"mi = mass of point i"}),"\n",(0,i.jsx)(e.li,{children:"xi, yi = position coordinates"}),"\n",(0,i.jsx)(e.li,{children:"x''i, y''i = acceleration"}),"\n",(0,i.jsx)(e.li,{children:"g = gravitational acceleration"}),"\n",(0,i.jsx)(e.li,{children:"z''i = vertical acceleration"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"center-of-pressure-cop-vs-zmp",children:"Center of Pressure (CoP) vs ZMP"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Center of Pressure (CoP)"}),": Point where the ground reaction force acts"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Zero Moment Point (ZMP)"}),": Point where net moment of active forces equals moment of passive forces"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"For stable walking, ZMP must remain within the support polygon defined by the feet."}),"\n",(0,i.jsx)(e.h2,{id:"walking-pattern-generation",children:"Walking Pattern Generation"}),"\n",(0,i.jsx)(e.h3,{id:"preview-control-method",children:"Preview Control Method"}),"\n",(0,i.jsx)(e.p,{children:"Preview control uses future reference trajectories to generate stable walking patterns:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'import numpy as np\nfrom scipy.linalg import solve_continuous_are\nfrom scipy.integrate import solve_ivp\n\nclass PreviewController:\n    def __init__(self, dt=0.01, preview_horizon=2.0):\n        self.dt = dt\n        self.preview_horizon = preview_horizon\n        self.preview_steps = int(preview_horizon / dt)\n\n    def compute_reference_trajectory(self, start_pos, goal_pos, walk_speed=0.3):\n        """Compute reference trajectory for walking"""\n        # Calculate distance to goal\n        dist = np.sqrt((goal_pos[0] - start_pos[0])**2 + (goal_pos[1] - start_pos[1])**2)\n\n        # Generate trajectory points\n        steps = int(dist / (walk_speed * self.dt))\n        x_traj = np.linspace(start_pos[0], goal_pos[0], steps)\n        y_traj = np.linspace(start_pos[1], goal_pos[1], steps)\n\n        # Add small sinusoidal variation for natural movement\n        t = np.arange(len(x_traj)) * self.dt\n        y_variation = 0.02 * np.sin(2 * np.pi * t * 0.5)  # Small vertical movement\n\n        return np.column_stack([x_traj, y_traj, y_variation])\n\n    def generate_footsteps(self, com_trajectory, step_length=0.3, step_width=0.2):\n        """Generate footstep locations based on CoM trajectory"""\n        footsteps = []\n        current_left = [0, step_width/2, 0]  # Start with left foot\n        current_right = [0, -step_width/2, 0]  # Start with right foot\n\n        for i, com_pos in enumerate(com_trajectory):\n            # Alternate steps based on phase\n            if i % (int(0.8 / self.dt) * 2) < int(0.8 / self.dt):  # Left foot phase\n                # Place left foot\n                target_x = com_pos[0] + step_length / 2\n                target_y = com_pos[1] + step_width / 2\n                current_left = [target_x, target_y, 0]\n            else:  # Right foot phase\n                # Place right foot\n                target_x = com_pos[0] + step_length / 2\n                target_y = com_pos[1] - step_width / 2\n                current_right = [target_x, target_y, 0]\n\n            # Add footstep to trajectory\n            if i % int(0.8 / self.dt) == 0:  # Add step every half cycle\n                if i % (int(0.8 / self.dt) * 2) < int(0.8 / self.dt):\n                    footsteps.append((\'left\', current_left))\n                else:\n                    footsteps.append((\'right\', current_right))\n\n        return footsteps\n'})}),"\n",(0,i.jsx)(e.h3,{id:"linear-inverted-pendulum-model-lipm",children:"Linear Inverted Pendulum Model (LIPM)"}),"\n",(0,i.jsx)(e.p,{children:"The Linear Inverted Pendulum Model simplifies humanoid balance:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'class LIPMController:\n    def __init__(self, com_height=0.8, gravity=9.81):\n        self.com_height = com_height\n        self.gravity = gravity\n        self.omega = np.sqrt(gravity / com_height)\n\n    def compute_zmp_from_com(self, com_pos, com_vel, com_acc):\n        """Compute ZMP from CoM position, velocity, and acceleration"""\n        zmp_x = com_pos[0] - (com_acc[0] / self.gravity) * self.com_height\n        zmp_y = com_pos[1] - (com_acc[1] / self.gravity) * self.com_height\n        return [zmp_x, zmp_y, 0]\n\n    def compute_com_from_zmp(self, zmp_pos, com_pos_prev, com_vel_prev):\n        """Compute CoM position from desired ZMP using LIPM"""\n        dt = 0.01  # Control timestep\n\n        # LIPM dynamics: com_ddot = omega^2 * (com - zmp)\n        com_acc = self.omega**2 * (np.array(com_pos_prev[:2]) - np.array(zmp_pos[:2]))\n\n        # Integrate to get new CoM position and velocity\n        new_com_vel = com_vel_prev[:2] + com_acc * dt\n        new_com_pos = com_pos_prev[:2] + new_com_vel * dt + 0.5 * com_acc * dt**2\n\n        return [new_com_pos[0], new_com_pos[1], self.com_height], new_com_vel\n'})}),"\n",(0,i.jsx)(e.h2,{id:"isaac-ros-humanoid-control-integration",children:"Isaac ROS Humanoid Control Integration"}),"\n",(0,i.jsx)(e.h3,{id:"isaac-ros-control-packages",children:"Isaac ROS Control Packages"}),"\n",(0,i.jsx)(e.p,{children:"Isaac ROS provides specialized packages for humanoid control:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-yaml",children:"# Isaac ROS Control configuration\nisaac_ros_control:\n  ros__parameters:\n    update_rate: 100  # Hz\n    controller_manager:\n      ros__parameters:\n        use_sim_time: true\n        controller_names:\n          - joint_state_broadcaster\n          - left_leg_controller\n          - right_leg_controller\n          - torso_controller\n          - head_controller\n\nleft_leg_controller:\n  ros__parameters:\n    type: position_controllers/JointGroupPositionController\n    joints:\n      - left_hip_roll\n      - left_hip_yaw\n      - left_hip_pitch\n      - left_knee\n      - left_ankle_pitch\n      - left_ankle_roll\n\nright_leg_controller:\n  ros__parameters:\n    type: position_controllers/JointGroupPositionController\n    joints:\n      - right_hip_roll\n      - right_hip_yaw\n      - right_hip_pitch\n      - right_knee\n      - right_ankle_pitch\n      - right_ankle_roll\n"})}),"\n",(0,i.jsx)(e.h3,{id:"humanoid-balance-controller",children:"Humanoid Balance Controller"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include <rclcpp/rclcpp.hpp>\n#include <sensor_msgs/msg/joint_state.hpp>\n#include <geometry_msgs/msg/vector3_stamped.hpp>\n#include <tf2_ros/transform_listener.h>\n#include <tf2_geometry_msgs/tf2_geometry_msgs.h>\n#include <Eigen/Dense>\n\nclass HumanoidBalanceController : public rclcpp::Node\n{\npublic:\n    HumanoidBalanceController() : Node("humanoid_balance_controller")\n    {\n        // Subscriptions\n        joint_state_sub_ = this->create_subscription<sensor_msgs::msg::JointState>(\n            "joint_states", 10,\n            std::bind(&HumanoidBalanceController::jointStateCallback, this, std::placeholders::_1)\n        );\n\n        imu_sub_ = this->create_subscription<sensor_msgs::msg::Imu>(\n            "imu/data", 10,\n            std::bind(&HumanoidBalanceController::imuCallback, this, std::placeholders::_1)\n        );\n\n        // Publishers\n        target_joints_pub_ = this->create_publisher<sensor_msgs::msg::JointState>(\n            "target_joint_positions", 10\n        );\n\n        // Timer for control loop\n        control_timer_ = this->create_wall_timer(\n            std::chrono::milliseconds(10),  // 100 Hz control\n            std::bind(&HumanoidBalanceController::controlLoop, this)\n        );\n\n        // Initialize balance controller parameters\n        com_height_ = this->declare_parameter("com_height", 0.8);\n        control_gain_ = this->declare_parameter("control_gain", 10.0);\n        max_correction_ = this->declare_parameter("max_correction", 0.1);\n\n        RCLCPP_INFO(this->get_logger(), "Humanoid Balance Controller initialized");\n    }\n\nprivate:\n    void jointStateCallback(const sensor_msgs::msg::JointState::SharedPtr msg)\n    {\n        // Store current joint states\n        current_joint_positions_ = msg->position;\n        current_joint_velocities_ = msg->velocity;\n        current_joint_efforts_ = msg->effort;\n        has_joint_state_ = true;\n    }\n\n    void imuCallback(const sensor_msgs::msg::Imu::SharedPtr msg)\n    {\n        // Store IMU data for balance feedback\n        imu_orientation_ = msg->orientation;\n        imu_angular_velocity_ = msg->angular_velocity;\n        imu_linear_acceleration_ = msg->linear_acceleration;\n        has_imu_data_ = true;\n    }\n\n    void controlLoop()\n    {\n        if (!has_joint_state_ || !has_imu_data_) {\n            return;  // Wait for sensor data\n        }\n\n        // Calculate current center of mass\n        auto com_pos = calculateCenterOfMass(current_joint_positions_);\n        auto com_vel = calculateCenterOfMassVelocity(current_joint_positions_, current_joint_velocities_);\n\n        // Calculate desired ZMP based on target trajectory\n        auto desired_zmp = calculateDesiredZMP();\n\n        // Calculate current ZMP from IMU and kinematics\n        auto current_zmp = calculateCurrentZMP(com_pos, com_vel, imu_linear_acceleration_);\n\n        // Compute balance error\n        double x_error = desired_zmp.x - current_zmp.x;\n        double y_error = desired_zmp.y - current_zmp.y;\n\n        // Generate corrective joint commands using PID control\n        auto correction_commands = computeBalanceCorrection(x_error, y_error);\n\n        // Apply corrections to joint targets\n        auto target_joints = applyBalanceCorrections(current_joint_positions_, correction_commands);\n\n        // Publish target joint positions\n        publishTargetJoints(target_joints);\n    }\n\n    geometry_msgs::msg::Point calculateCenterOfMass(const std::vector<double>& joint_positions)\n    {\n        // Calculate CoM based on joint positions and link masses\n        // This is a simplified implementation - in practice, use URDF info\n        geometry_msgs::msg::Point com;\n\n        // For a simplified model, assume CoM is at fixed height\n        // and calculate horizontal position based on joint angles\n        double com_x = 0.0, com_y = 0.0;\n\n        // Simplified CoM calculation (would use full kinematic model in practice)\n        for (size_t i = 0; i < joint_positions.size(); ++i) {\n            // Weight each joint contribution based on its position in the kinematic chain\n            com_x += joint_positions[i] * 0.01;  // Simplified weighting\n            com_y += joint_positions[i] * 0.01;  // Simplified weighting\n        }\n\n        com.x = com_x;\n        com.y = com_y;\n        com.z = com_height_;\n\n        return com;\n    }\n\n    geometry_msgs::msg::Point calculateCurrentZMP(\n        const geometry_msgs::msg::Point& com_pos,\n        const geometry_msgs::msg::Point& com_vel,\n        const geometry_msgs::msg::Vector3& linear_acc)\n    {\n        // Calculate ZMP from CoM and acceleration data\n        // ZMP_x = CoM_x - (CoM_z * CoM_acc_x) / g\n        // ZMP_y = CoM_y - (CoM_z * CoM_acc_y) / g\n\n        geometry_msgs::msg::Point zmp;\n        zmp.x = com_pos.x - (com_pos.z * linear_acc.x) / gravity_;\n        zmp.y = com_pos.y - (com_pos.z * linear_acc.y) / gravity_;\n        zmp.z = 0.0;  // ZMP is on the ground plane\n\n        return zmp;\n    }\n\n    std::vector<double> computeBalanceCorrection(double x_error, double y_error)\n    {\n        // Simple PD controller for balance correction\n        static double prev_x_error = 0, prev_y_error = 0;\n        static double integral_x_error = 0, integral_y_error = 0;\n\n        // PID parameters\n        double kp = 100.0;  // Proportional gain\n        double ki = 10.0;   // Integral gain\n        double kd = 50.0;   // Derivative gain\n\n        // Update error integrals\n        integral_x_error += x_error * dt_;\n        integral_y_error += y_error * dt_;\n\n        // Calculate derivatives\n        double dx_error = (x_error - prev_x_error) / dt_;\n        double dy_error = (y_error - prev_y_error) / dt_;\n\n        // Compute control outputs\n        double x_control = kp * x_error + ki * integral_x_error + kd * dx_error;\n        double y_control = kp * y_error + ki * integral_y_error + kd * dy_error;\n\n        // Limit control outputs\n        x_control = std::max(-max_correction_, std::min(max_correction_, x_control));\n        y_control = std::max(-max_correction_, std::min(max_correction_, y_control));\n\n        // Convert to joint space corrections\n        // This would involve inverse kinematics in a real implementation\n        std::vector<double> corrections(num_joints_, 0.0);\n\n        // Simplified mapping - in practice, use full inverse kinematics\n        corrections[left_hip_roll_idx_] = x_control * 0.1;\n        corrections[right_hip_roll_idx_] = -x_control * 0.1;\n        corrections[left_ankle_roll_idx_] = -x_control * 0.2;\n        corrections[right_ankle_roll_idx_] = x_control * 0.2;\n\n        corrections[left_hip_pitch_idx_] = y_control * 0.1;\n        corrections[right_hip_pitch_idx_] = y_control * 0.1;\n        corrections[left_ankle_pitch_idx_] = -y_control * 0.2;\n        corrections[right_ankle_pitch_idx_] = -y_control * 0.2;\n\n        prev_x_error = x_error;\n        prev_y_error = y_error;\n\n        return corrections;\n    }\n\n    void publishTargetJoints(const std::vector<double>& target_positions)\n    {\n        auto msg = sensor_msgs::msg::JointState();\n        msg.header.stamp = this->now();\n        msg.name = joint_names_;  // Would be initialized with actual joint names\n        msg.position = target_positions;\n\n        target_joints_pub_->publish(msg);\n    }\n\n    // Subscriptions\n    rclcpp::Subscription<sensor_msgs::msg::JointState>::SharedPtr joint_state_sub_;\n    rclcpp::Subscription<sensor_msgs::msg::Imu>::SharedPtr imu_sub_;\n\n    // Publishers\n    rclcpp::Publisher<sensor_msgs::msg::JointState>::SharedPtr target_joints_pub_;\n\n    // Timer\n    rclcpp::TimerBase::SharedPtr control_timer_;\n\n    // State variables\n    std::vector<double> current_joint_positions_;\n    std::vector<double> current_joint_velocities_;\n    std::vector<double> current_joint_efforts_;\n    geometry_msgs::msg::Quaternion imu_orientation_;\n    geometry_msgs::msg::Vector3 imu_angular_velocity_;\n    geometry_msgs::msg::Vector3 imu_linear_acceleration_;\n\n    bool has_joint_state_ = false;\n    bool has_imu_data_ = false;\n\n    // Balance control parameters\n    double com_height_;\n    double control_gain_;\n    double max_correction_;\n    double gravity_ = 9.81;\n    double dt_ = 0.01;  // Control timestep\n\n    // Joint indices (would be initialized based on actual robot)\n    int left_hip_roll_idx_ = 0;\n    int right_hip_roll_idx_ = 1;\n    // ... other joint indices\n};\n'})}),"\n",(0,i.jsx)(e.h2,{id:"isaac-sim-humanoid-simulation",children:"Isaac Sim Humanoid Simulation"}),"\n",(0,i.jsx)(e.h3,{id:"creating-humanoid-robots-in-isaac-sim",children:"Creating Humanoid Robots in Isaac Sim"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'# Isaac Sim humanoid robot setup\nimport omni\nfrom omni.isaac.core import World\nfrom omni.isaac.core.utils.stage import add_reference_to_stage\nfrom omni.isaac.core.utils.nucleus import get_assets_root_path\nfrom omni.isaac.core.articulations import ArticulationView\nfrom omni.isaac.core.utils.prims import get_prim_at_path\nimport numpy as np\n\nclass IsaacHumanoidRobot:\n    def __init__(self, prim_path="/World/HumanoidRobot", name="humanoid"):\n        self.prim_path = prim_path\n        self.name = name\n        self.world = World()\n\n        # Add humanoid robot to stage\n        assets_root_path = get_assets_root_path()\n        if assets_root_path is None:\n            print("Could not find Isaac Sim assets. Please check your Isaac Sim installation.")\n            return\n\n        # Use a humanoid robot asset (example with Carter robot - replace with actual humanoid)\n        robot_asset_path = assets_root_path + "/Isaac/Robots/Humanoid/humanoid_instanceable.usd"\n        add_reference_to_stage(usd_path=robot_asset_path, prim_path=prim_path)\n\n        # Create articulation view for the robot\n        self.robot_articulation = ArticulationView(prim_path=prim_path + "/base_link", name=name + "_view")\n        self.world.add_articulation(self.robot_articulation)\n\n    def initialize_robot(self):\n        """Initialize robot in simulation"""\n        self.world.reset()\n\n        # Set default joint positions for standing pose\n        default_positions = np.array([\n            0.0,  # left_hip_roll\n            0.0,  # left_hip_yaw\n            0.0,  # left_hip_pitch\n            0.0,  # left_knee\n            0.0,  # left_ankle_pitch\n            0.0,  # left_ankle_roll\n            0.0,  # right_hip_roll\n            0.0,  # right_hip_yaw\n            0.0,  # right_hip_pitch\n            0.0,  # right_knee\n            0.0,  # right_ankle_pitch\n            0.0,  # right_ankle_roll\n            # ... add other joints\n        ])\n\n        self.robot_articulation.set_joint_positions(default_positions)\n\n    def move_to_standing_pose(self):\n        """Move robot to neutral standing pose"""\n        standing_positions = np.array([\n            0.0,   # left_hip_roll\n            0.0,   # left_hip_yaw\n            0.0,   # left_hip_pitch (neutral)\n            0.0,   # left_knee (straight)\n            0.0,   # left_ankle_pitch\n            0.0,   # left_ankle_roll\n            0.0,   # right_hip_roll\n            0.0,   # right_hip_yaw\n            0.0,   # right_hip_pitch (neutral)\n            0.0,   # right_knee (straight)\n            0.0,   # right_ankle_pitch\n            0.0,   # right_ankle_roll\n        ])\n\n        self.robot_articulation.set_joint_positions(standing_positions)\n\n    def execute_walk_cycle(self, step_phase, step_length=0.3, step_height=0.05):\n        """Execute a single step in walking cycle"""\n        # Calculate joint positions based on step phase (0 to 1)\n        # This is a simplified walking pattern - in practice, use proper gait generation\n\n        # Left leg trajectory\n        left_knee_angle = np.sin(step_phase * 2 * np.pi) * 0.3  # Knee bend\n        left_ankle_pitch = -left_knee_angle * 0.5  # Compensate for knee movement\n\n        # Right leg trajectory (opposite phase)\n        right_phase = (step_phase + 0.5) % 1.0\n        right_knee_angle = np.sin(right_phase * 2 * np.pi) * 0.3\n        right_ankle_pitch = -right_knee_angle * 0.5\n\n        # Hip adjustments for balance\n        pelvis_roll = np.sin(step_phase * 2 * np.pi) * 0.1  # Shift weight\n\n        target_positions = np.array([\n            pelvis_roll,  # left_hip_roll\n            0.0,          # left_hip_yaw\n            0.0,          # left_hip_pitch\n            left_knee_angle,      # left_knee\n            left_ankle_pitch,     # left_ankle_pitch\n            0.0,          # left_ankle_roll\n            -pelvis_roll, # right_hip_roll (opposite to maintain balance)\n            0.0,          # right_hip_yaw\n            0.0,          # right_hip_pitch\n            right_knee_angle,     # right_knee\n            right_ankle_pitch,    # right_ankle_pitch\n            0.0,          # right_ankle_roll\n        ])\n\n        self.robot_articulation.set_joint_positions(target_positions)\n\n    def get_robot_state(self):\n        """Get current robot state including joint positions, velocities, and CoM"""\n        joint_positions = self.robot_articulation.get_joint_positions()\n        joint_velocities = self.robot_articulation.get_joint_velocities()\n\n        # Calculate center of mass position and velocity\n        com_position = self.calculate_center_of_mass(joint_positions)\n        com_velocity = self.calculate_center_of_mass_velocity(joint_positions, joint_velocities)\n\n        robot_state = {\n            \'joint_positions\': joint_positions,\n            \'joint_velocities\': joint_velocities,\n            \'com_position\': com_position,\n            \'com_velocity\': com_velocity,\n            \'base_position\': self.robot_articulation.get_world_poses()[0][0],\n            \'base_orientation\': self.robot_articulation.get_world_poses()[1][0]\n        }\n\n        return robot_state\n\n    def calculate_center_of_mass(self, joint_positions):\n        """Calculate center of mass position from joint configuration"""\n        # Simplified CoM calculation - in practice, use URDF mass properties\n        # This would involve forward kinematics and mass-weighted averaging\n\n        # For now, return a simplified estimate\n        return np.array([0.0, 0.0, 0.8])  # Approximate CoM height for humanoid\n\n    def calculate_center_of_mass_velocity(self, joint_positions, joint_velocities):\n        """Calculate center of mass velocity"""\n        # Simplified CoM velocity calculation\n        return np.array([0.0, 0.0, 0.0])\n'})}),"\n",(0,i.jsx)(e.h2,{id:"gait-planning-and-execution",children:"Gait Planning and Execution"}),"\n",(0,i.jsx)(e.h3,{id:"walking-pattern-generator",children:"Walking Pattern Generator"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'class WalkingPatternGenerator:\n    def __init__(self, step_length=0.3, step_width=0.2, step_height=0.05, step_duration=0.8):\n        self.step_length = step_length\n        self.step_width = step_width\n        self.step_height = step_height\n        self.step_duration = step_duration\n        self.dt = 0.01  # Control timestep\n\n    def generate_walk_trajectory(self, distance, direction=\'forward\'):\n        """Generate complete walk trajectory for given distance"""\n        # Calculate number of steps needed\n        step_count = int(distance / self.step_length)\n\n        trajectory = []\n\n        for step_num in range(step_count):\n            # Generate single step trajectory\n            step_trajectory = self.generate_single_step(step_num % 2 == 0)  # Alternate feet\n            trajectory.extend(step_trajectory)\n\n        return trajectory\n\n    def generate_single_step(self, use_left_foot=True):\n        """Generate trajectory for a single step"""\n        steps_per_phase = int(self.step_duration / self.dt / 4)  # 4 phases per step\n\n        trajectory = []\n\n        # Phase 1: Preparation (lift foot slightly)\n        for i in range(steps_per_phase):\n            t = i / steps_per_phase\n            lift_amount = self.step_height * 0.3 * t  # Gentle lift\n\n            joint_positions = self.calculate_step_joints(\n                phase=t,\n                foot_lift=lift_amount,\n                swing_foot=use_left_foot\n            )\n            trajectory.append(joint_positions)\n\n        # Phase 2: Swing (move foot forward)\n        for i in range(steps_per_phase):\n            t = i / steps_per_phase\n            forward_progress = self.step_length * t\n            foot_lift = self.step_height * (1 - (t - 0.5)**2)  # Parabolic lift\n\n            joint_positions = self.calculate_step_joints(\n                phase=t,\n                forward_progress=forward_progress,\n                foot_lift=foot_lift,\n                swing_foot=use_left_foot\n            )\n            trajectory.append(joint_positions)\n\n        # Phase 3: Landing (lower foot)\n        for i in range(steps_per_phase):\n            t = i / steps_per_phase\n            foot_lift = self.step_height * (1 - t)  # Lower foot\n            forward_progress = self.step_length\n\n            joint_positions = self.calculate_step_joints(\n                phase=t,\n                forward_progress=forward_progress,\n                foot_lift=foot_lift,\n                swing_foot=use_left_foot\n            )\n            trajectory.append(joint_positions)\n\n        # Phase 4: Stabilization (adjust for balance)\n        for i in range(steps_per_phase):\n            t = i / steps_per_phase\n            joint_positions = self.calculate_stance_joints(use_left_foot)\n            trajectory.append(joint_positions)\n\n        return trajectory\n\n    def calculate_step_joints(self, phase, forward_progress=0, foot_lift=0, swing_foot=True):\n        """Calculate joint positions for step execution"""\n        # This would implement inverse kinematics for foot placement\n        # For simplicity, return a basic pattern\n\n        if swing_foot:  # Left foot is swinging\n            # Move left foot forward and lift it\n            left_knee = np.clip(foot_lift * 3, 0, 0.5)  # Knee bend for lifting\n            left_ankle = -foot_lift  # Compensate ankle for lift\n            right_knee = 0.0  # Right leg straight\n            right_ankle = 0.0\n        else:  # Right foot is swinging\n            right_knee = np.clip(foot_lift * 3, 0, 0.5)\n            right_ankle = -foot_lift\n            left_knee = 0.0\n            left_ankle = 0.0\n\n        # Hip adjustments for balance during step\n        hip_adjustment = foot_lift * 0.2 if foot_lift > 0 else 0.0\n\n        joint_positions = np.zeros(12)  # Assuming 12 leg joints\n        joint_positions[3] = left_knee    # left_knee\n        joint_positions[4] = left_ankle   # left_ankle_pitch\n        joint_positions[9] = right_knee   # right_knee\n        joint_positions[10] = right_ankle # right_ankle_pitch\n\n        if swing_foot:\n            joint_positions[2] = hip_adjustment   # left_hip_pitch (raise opposite hip)\n            joint_positions[8] = -hip_adjustment  # right_hip_pitch (lower swing hip)\n        else:\n            joint_positions[2] = -hip_adjustment  # left_hip_pitch (lower swing hip)\n            joint_positions[8] = hip_adjustment   # right_hip_pitch (raise opposite hip)\n\n        return joint_positions\n\n    def calculate_stance_joints(self, stance_foot_is_left):\n        """Calculate joint positions for stable stance"""\n        # Return neutral standing position with slight knee bend\n        joint_positions = np.zeros(12)\n        joint_positions[3] = 0.1  # Slight knee bend for stability\n        joint_positions[9] = 0.1  # Slight knee bend for stability\n        return joint_positions\n'})}),"\n",(0,i.jsx)(e.h2,{id:"ros-2-integration-for-humanoid-control",children:"ROS 2 Integration for Humanoid Control"}),"\n",(0,i.jsx)(e.h3,{id:"humanoid-controller-manager",children:"Humanoid Controller Manager"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include <rclcpp/rclcpp.hpp>\n#include <std_msgs/msg/float64_multi_array.hpp>\n#include <sensor_msgs/msg/joint_state.hpp>\n#include <geometry_msgs/msg/twist.h>\n#include <control_msgs/msg/joint_trajectory_controller_state.hpp>\n\nclass HumanoidControllerManager : public rclcpp::Node\n{\npublic:\n    HumanoidControllerManager() : Node("humanoid_controller_manager")\n    {\n        // Initialize humanoid-specific controllers\n        initializeControllers();\n\n        // Create subscribers for different command types\n        cmd_vel_sub_ = this->create_subscription<geometry_msgs::msg::Twist>(\n            "cmd_vel", 10,\n            std::bind(&HumanoidControllerManager::cmdVelCallback, this, std::placeholders::_1)\n        );\n\n        joint_command_sub_ = this->create_subscription<std_msgs::msg::Float64MultiArray>(\n            "joint_group_position_controller/commands", 10,\n            std::bind(&HumanoidControllerManager::jointCommandCallback, this, std::placeholders::_1)\n        );\n\n        // Publishers for robot state\n        robot_state_pub_ = this->create_publisher<sensor_msgs::msg::JointState>(\n            "robot_state", 10\n        );\n\n        // Timer for control loop\n        control_timer_ = this->create_wall_timer(\n            std::chrono::milliseconds(10),  // 100 Hz\n            std::bind(&HumanoidControllerManager::controlLoop, this)\n        );\n\n        RCLCPP_INFO(this->get_logger(), "Humanoid Controller Manager initialized");\n    }\n\nprivate:\n    void cmdVelCallback(const geometry_msgs::msg::Twist::SharedPtr msg)\n    {\n        // Convert velocity command to walking pattern\n        requested_linear_vel_ = msg->linear.x;\n        requested_angular_vel_ = msg->angular.z;\n\n        // Generate appropriate gait pattern based on velocity request\n        generateWalkPattern(requested_linear_vel_, requested_angular_vel_);\n    }\n\n    void jointCommandCallback(const std_msgs::msg::Float64MultiArray::SharedPtr msg)\n    {\n        // Handle direct joint position commands\n        target_joint_positions_ = msg->data;\n        control_mode_ = JOINT_POSITION_CONTROL;\n    }\n\n    void controlLoop()\n    {\n        // Get current robot state\n        auto current_state = getCurrentRobotState();\n\n        // Apply appropriate control based on mode\n        std::vector<double> commands;\n\n        switch (control_mode_) {\n            case WALK_CONTROL:\n                commands = generateWalkCommands(current_state);\n                break;\n            case JOINT_POSITION_CONTROL:\n                commands = generateJointPositionCommands(current_state);\n                break;\n            case BALANCE_CONTROL:\n                commands = generateBalanceCommands(current_state);\n                break;\n            default:\n                commands = std::vector<double>(num_joints_, 0.0);\n                break;\n        }\n\n        // Apply commands to robot\n        sendJointCommands(commands);\n\n        // Publish robot state\n        publishRobotState(current_state);\n    }\n\n    std::vector<double> generateWalkCommands(const RobotState& state)\n    {\n        // Generate walking pattern based on requested velocities\n        std::vector<double> commands(num_joints_, 0.0);\n\n        // Calculate step parameters based on requested velocities\n        double step_frequency = calculateStepFrequency(requested_linear_vel_);\n        double step_length = calculateStepLength(requested_linear_vel_);\n        double turn_compensation = calculateTurnCompensation(requested_angular_vel_);\n\n        // Generate walking pattern\n        auto walk_pattern = walking_generator_.generateWalkingPattern(\n            step_frequency, step_length, turn_compensation, state\n        );\n\n        // Convert to joint commands\n        commands = walk_pattern.toJointCommands();\n\n        return commands;\n    }\n\n    void initializeControllers()\n    {\n        // Initialize different controller types:\n        // - Joint position controllers for each limb\n        // - Balance controller for CoM management\n        // - Walking pattern generator\n        // - Impedance controllers for compliant behavior\n\n        walking_generator_.initialize();\n        balance_controller_.initialize();\n        impedance_controllers_.initialize();\n    }\n\n    enum ControlMode {\n        WALK_CONTROL,\n        JOINT_POSITION_CONTROL,\n        BALANCE_CONTROL,\n        TRAJECTORY_CONTROL\n    };\n\n    ControlMode control_mode_ = WALK_CONTROL;\n\n    // Subscriptions\n    rclcpp::Subscription<geometry_msgs::msg::Twist>::SharedPtr cmd_vel_sub_;\n    rclcpp::Subscription<std_msgs::msg::Float64MultiArray>::SharedPtr joint_command_sub_;\n\n    // Publishers\n    rclcpp::Publisher<sensor_msgs::msg::JointState>::SharedPtr robot_state_pub_;\n\n    // Timer\n    rclcpp::TimerBase::SharedPtr control_timer_;\n\n    // State variables\n    double requested_linear_vel_ = 0.0;\n    double requested_angular_vel_ = 0.0;\n    std::vector<double> target_joint_positions_;\n    std::vector<std::string> joint_names_;\n\n    // Controllers\n    WalkingPatternGenerator walking_generator_;\n    BalanceController balance_controller_;\n    ImpedanceControllerManager impedance_controllers_;\n\n    // Constants\n    const size_t num_joints_ = 28;  // Typical humanoid has ~28+ joints\n};\n'})}),"\n",(0,i.jsx)(e.h2,{id:"advanced-locomotion-patterns",children:"Advanced Locomotion Patterns"}),"\n",(0,i.jsx)(e.h3,{id:"different-gait-types",children:"Different Gait Types"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'class GaitController:\n    def __init__(self):\n        self.current_gait = "walking"\n        self.gait_parameters = {\n            "walking": {\n                "step_length": 0.3,\n                "step_height": 0.05,\n                "step_duration": 0.8,\n                "stance_ratio": 0.6\n            },\n            "trotting": {\n                "step_length": 0.4,\n                "step_height": 0.1,\n                "step_duration": 0.4,\n                "stance_ratio": 0.4\n            },\n            "crawling": {\n                "step_length": 0.1,\n                "step_height": 0.02,\n                "step_duration": 1.0,\n                "stance_ratio": 0.8\n            }\n        }\n\n    def switch_gait(self, gait_type):\n        """Switch between different locomotion gaits"""\n        if gait_type in self.gait_parameters:\n            self.current_gait = gait_type\n            self.update_gait_parameters(self.gait_parameters[gait_type])\n            return True\n        return False\n\n    def generate_gait_pattern(self, velocity, terrain_type="flat"):\n        """Generate gait pattern based on velocity and terrain"""\n        gait_params = self.gait_parameters[self.current_gait]\n\n        if terrain_type == "rough":\n            # Adjust parameters for rough terrain\n            gait_params["step_height"] *= 1.5\n            gait_params["step_length"] *= 0.7\n            gait_params["step_duration"] *= 1.2\n\n        elif terrain_type == "stairs":\n            # Special pattern for stair climbing\n            return self.generate_stair_climbing_pattern(velocity)\n\n        elif terrain_type == "narrow":\n            # Adjust for narrow passages\n            gait_params["step_width"] = 0.1  # Narrower steps\n\n        # Generate appropriate pattern based on current gait\n        if self.current_gait == "walking":\n            return self.generate_walking_pattern(velocity, gait_params)\n        elif self.current_gait == "trotting":\n            return self.generate_trotting_pattern(velocity, gait_params)\n        elif self.current_gait == "crawling":\n            return self.generate_crawling_pattern(velocity, gait_params)\n\n    def generate_stair_climbing_pattern(self, velocity):\n        """Generate special pattern for stair climbing"""\n        # Stair climbing requires specific foot placement and balance\n        # This is a simplified implementation\n        pattern = []\n\n        # Approach step\n        approach_joints = self.calculate_stance_joints()\n        pattern.extend([approach_joints] * 10)  # Hold approach position\n\n        # Lift swing foot to step height\n        for i in range(20):  # 0.2 seconds at 100Hz\n            t = i / 20.0\n            lift_amount = 0.15 * np.sin(np.pi * t)  # Lift to step height\n            joints = self.calculate_stance_joints()\n            # Apply lift to swing foot (simplified)\n            pattern.append(joints)\n\n        # Move swing foot forward over step\n        for i in range(20):\n            t = i / 20.0\n            forward_amount = 0.3 * t  # Move forward by step depth\n            joints = self.calculate_stance_joints()\n            pattern.append(joints)\n\n        # Lower swing foot to next step\n        for i in range(20):\n            t = i / 20.0\n            lower_amount = 0.15 * (1 - np.cos(np.pi * t))  # Smooth lowering\n            joints = self.calculate_stance_joints()\n            pattern.append(joints)\n\n        return pattern\n\n    def adapt_to_terrain(self, terrain_analysis):\n        """Adapt gait based on terrain analysis from perception system"""\n        # Analyze terrain characteristics\n        slope = terrain_analysis.get(\'slope\', 0)\n        step_height = terrain_analysis.get(\'step_height\', 0)\n        surface_roughness = terrain_analysis.get(\'roughness\', 0)\n        obstacles = terrain_analysis.get(\'obstacles\', [])\n\n        # Select appropriate gait based on terrain\n        if slope > 15:  # Steep incline\n            self.switch_gait("crawling")\n        elif step_height > 0.1:  # Significant height changes\n            # Use special climbing gait\n            pass\n        elif surface_roughness > 0.5:  # Very rough terrain\n            self.switch_gait("crawling")\n            self.reduce_step_length(0.5)\n        else:\n            self.switch_gait("walking")\n\n        # Adjust parameters based on terrain\n        if obstacles:\n            self.enable_obstacle_aware_navigation(obstacles)\n'})}),"\n",(0,i.jsx)(e.h2,{id:"balance-recovery-behaviors",children:"Balance Recovery Behaviors"}),"\n",(0,i.jsx)(e.h3,{id:"fall-prevention-and-recovery",children:"Fall Prevention and Recovery"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"class BalanceRecoverySystem\n{\npublic:\n    BalanceRecoverySystem() {\n        state_ = BALANCED;\n        recovery_threshold_ = 0.3;  // ZMP outside support polygon threshold\n        fall_threshold_ = 0.5;      // Critical imbalance threshold\n    }\n\n    BalanceState assessBalance(const RobotState& state)\n    {\n        // Calculate ZMP and compare to support polygon\n        auto zmp = calculateZMP(state);\n        auto support_polygon = calculateSupportPolygon(state);\n\n        if (isOutsideSupportPolygon(zmp, support_polygon)) {\n            double distance = distanceToSupportPolygon(zmp, support_polygon);\n\n            if (distance > fall_threshold_) {\n                state_ = FALLING;\n                return state_;\n            } else if (distance > recovery_threshold_) {\n                state_ = UNBALANCED;\n                initiateRecovery(state);\n                return state_;\n            }\n        }\n\n        state_ = BALANCED;\n        return state_;\n    }\n\n    void initiateRecovery(const RobotState& state)\n    {\n        // Choose appropriate recovery action based on situation\n        if (fabs(state.com_velocity.z) > 0.5) {\n            // Falling - use protective landing\n            executeProtectiveLanding(state);\n        } else if (state.foot_contacts[LEFT_FOOT] && state.foot_contacts[RIGHT_FOOT]) {\n            // Stable stance - use ankle strategy\n            executeAnkleStrategy(state);\n        } else {\n            // Single support - use hip/stepping strategy\n            executeHipSteppingStrategy(state);\n        }\n    }\n\n    void executeAnkleStrategy(const RobotState& state)\n    {\n        // Ankle strategy: use ankle torques to shift CoM back to support\n        double x_error = calculateZMPErrors(state).x;\n        double y_error = calculateZMPErrors(state).y;\n\n        // Simple PD control on ankle joints\n        double ankle_roll_command = -kp_ankle_roll_ * x_error - kd_ankle_roll_ * state.ankle_velocities[ROLL];\n        double ankle_pitch_command = -kp_ankle_pitch_ * y_error - kd_ankle_pitch_ * state.ankle_velocities[PITCH];\n\n        // Apply commands\n        setAnkleTorques(ankle_roll_command, ankle_pitch_command);\n    }\n\n    void executeHipSteppingStrategy(const RobotState& state)\n    {\n        // Hip strategy: use hip torques and stepping to recover balance\n        auto zmp_error = calculateZMPErrors(state);\n\n        // Decide if to step or use hip torques based on severity\n        if (fabs(zmp_error.x) > 0.2 || fabs(zmp_error.y) > 0.2) {\n            // Severe imbalance - plan emergency step\n            planEmergencyStep(state, zmp_error);\n        } else {\n            // Moderate imbalance - use hip torques\n            executeHipStrategy(state, zmp_error);\n        }\n    }\n\nprivate:\n    BalanceState state_;\n    double recovery_threshold_;\n    double fall_threshold_;\n\n    // Control gains\n    double kp_ankle_roll_ = 50.0;\n    double kd_ankle_roll_ = 10.0;\n    double kp_ankle_pitch_ = 50.0;\n    double kd_ankle_pitch_ = 10.0;\n    double kp_hip_roll_ = 100.0;\n    double kd_hip_roll_ = 20.0;\n    double kp_hip_pitch_ = 100.0;\n    double kd_hip_pitch_ = 20.0;\n};\n"})}),"\n",(0,i.jsx)(e.h2,{id:"performance-evaluation",children:"Performance Evaluation"}),"\n",(0,i.jsx)(e.h3,{id:"metrics-for-humanoid-locomotion",children:"Metrics for Humanoid Locomotion"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"class LocomotionEvaluator:\n    def __init__(self):\n        self.metrics = {\n            'stability': [],\n            'efficiency': [],\n            'balance': [],\n            'trajectory_accuracy': [],\n            'energy_consumption': []\n        }\n\n    def evaluate_locomotion_performance(self, robot_state, reference_trajectory):\n        \"\"\"Evaluate humanoid locomotion performance\"\"\"\n\n        # Stability metrics\n        zmp_stability = self.calculate_zmp_stability(robot_state)\n        self.metrics['stability'].append(zmp_stability)\n\n        # Balance metrics\n        com_deviation = self.calculate_com_deviation(robot_state)\n        self.metrics['balance'].append(com_deviation)\n\n        # Efficiency metrics\n        energy_used = self.calculate_energy_consumption(robot_state)\n        self.metrics['efficiency'].append(energy_used)\n\n        # Trajectory tracking accuracy\n        tracking_error = self.calculate_trajectory_error(robot_state, reference_trajectory)\n        self.metrics['trajectory_accuracy'].append(tracking_error)\n\n        return {\n            'stability_score': self.calculate_average('stability'),\n            'balance_score': self.calculate_average('balance'),\n            'efficiency_score': self.calculate_average('efficiency'),\n            'accuracy_score': self.calculate_average('trajectory_accuracy')\n        }\n\n    def calculate_zmp_stability(self, state):\n        \"\"\"Calculate ZMP-based stability metric\"\"\"\n        zmp = state['zmp']\n        support_polygon = state['support_polygon']\n\n        # Calculate distance from ZMP to edge of support polygon\n        distance_to_edge = self.distance_to_polygon_edge(zmp, support_polygon)\n\n        # Normalize by support polygon area\n        support_area = self.calculate_polygon_area(support_polygon)\n        stability_metric = distance_to_edge / np.sqrt(support_area)\n\n        return stability_metric\n\n    def calculate_energy_consumption(self, state):\n        \"\"\"Calculate energy consumption based on joint torques and velocities\"\"\"\n        total_energy = 0.0\n\n        for i, (torque, velocity) in enumerate(zip(state['joint_torques'], state['joint_velocities'])):\n            # Energy = integral of torque * velocity over time\n            instantaneous_power = abs(torque * velocity)\n            total_energy += instantaneous_power * self.dt  # dt = control timestep\n\n        return total_energy\n\n    def calculate_trajectory_error(self, robot_state, reference_trajectory):\n        \"\"\"Calculate error between robot position and reference trajectory\"\"\"\n        robot_pos = np.array([robot_state['position']['x'], robot_state['position']['y']])\n\n        # Find closest point on reference trajectory\n        min_distance = float('inf')\n        for ref_point in reference_trajectory:\n            dist = np.linalg.norm(robot_pos - np.array([ref_point['x'], ref_point['y']]))\n            min_distance = min(min_distance, dist)\n\n        return min_distance\n"})}),"\n",(0,i.jsx)(e.h2,{id:"troubleshooting-common-issues",children:"Troubleshooting Common Issues"}),"\n",(0,i.jsx)(e.h3,{id:"1-instability-and-falls",children:"1. Instability and Falls"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Problem"}),": Robot falls during walking\n",(0,i.jsx)(e.strong,{children:"Solutions"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Check CoM height parameter in controller"}),"\n",(0,i.jsx)(e.li,{children:"Verify joint limits and physical properties"}),"\n",(0,i.jsx)(e.li,{children:"Adjust balance controller gains"}),"\n",(0,i.jsx)(e.li,{children:"Ensure proper initial standing pose"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"2-joint-limit-violations",children:"2. Joint Limit Violations"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Problem"}),": Joints reaching limits during walking\n",(0,i.jsx)(e.strong,{children:"Solutions"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Check URDF joint limits"}),"\n",(0,i.jsx)(e.li,{children:"Adjust gait parameters (step height/length)"}),"\n",(0,i.jsx)(e.li,{children:"Implement joint limit checking in controller"}),"\n",(0,i.jsx)(e.li,{children:"Use trajectory optimization to respect limits"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"3-zmp-outside-support-polygon",children:"3. ZMP Outside Support Polygon"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Problem"}),": Balance errors during locomotion\n",(0,i.jsx)(e.strong,{children:"Solutions"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Reduce walking speed"}),"\n",(0,i.jsx)(e.li,{children:"Increase step width"}),"\n",(0,i.jsx)(e.li,{children:"Adjust CoM height"}),"\n",(0,i.jsx)(e.li,{children:"Improve sensor feedback quality"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"4-phase-synchronization-issues",children:"4. Phase Synchronization Issues"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Problem"}),": Legs getting out of sync during walking\n",(0,i.jsx)(e.strong,{children:"Solutions"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Verify gait phase calculation"}),"\n",(0,i.jsx)(e.li,{children:"Check timing synchronization"}),"\n",(0,i.jsx)(e.li,{children:"Ensure proper step sequencing"}),"\n",(0,i.jsx)(e.li,{children:"Use phase oscillator models"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(e.h3,{id:"1-gradual-complexity-increase",children:"1. Gradual Complexity Increase"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Start with standing balance control"}),"\n",(0,i.jsx)(e.li,{children:"Progress to simple stepping"}),"\n",(0,i.jsx)(e.li,{children:"Add forward walking"}),"\n",(0,i.jsx)(e.li,{children:"Introduce turning and complex maneuvers"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"2-safety-first-approach",children:"2. Safety First Approach"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Implement soft limits and safety controllers"}),"\n",(0,i.jsx)(e.li,{children:"Use simulation extensively before real robot testing"}),"\n",(0,i.jsx)(e.li,{children:"Have emergency stop mechanisms"}),"\n",(0,i.jsx)(e.li,{children:"Monitor robot state continuously"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"3-parameter-tuning",children:"3. Parameter Tuning"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Start with conservative parameters"}),"\n",(0,i.jsx)(e.li,{children:"Gradually increase aggressiveness"}),"\n",(0,i.jsx)(e.li,{children:"Test on various terrains"}),"\n",(0,i.jsx)(e.li,{children:"Validate with multiple scenarios"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"4-sensor-fusion",children:"4. Sensor Fusion"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Combine multiple sensor inputs"}),"\n",(0,i.jsx)(e.li,{children:"Use IMU for orientation feedback"}),"\n",(0,i.jsx)(e.li,{children:"Implement sensor validation"}),"\n",(0,i.jsx)(e.li,{children:"Handle sensor failures gracefully"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"exercise",children:"Exercise"}),"\n",(0,i.jsx)(e.p,{children:"Create a complete humanoid locomotion system that includes:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"Implement a ZMP-based balance controller"}),"\n",(0,i.jsx)(e.li,{children:"Create a walking pattern generator with adjustable parameters"}),"\n",(0,i.jsx)(e.li,{children:"Integrate with Isaac Sim for humanoid robot simulation"}),"\n",(0,i.jsx)(e.li,{children:"Implement gait switching capabilities (walking, crawling, stair climbing)"}),"\n",(0,i.jsx)(e.li,{children:"Add balance recovery behaviors for disturbance rejection"}),"\n",(0,i.jsx)(e.li,{children:"Create a navigation system that uses the locomotion controller"}),"\n",(0,i.jsx)(e.li,{children:"Evaluate the system's performance with stability and efficiency metrics"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"Test your system with various scenarios including:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Straight line walking"}),"\n",(0,i.jsx)(e.li,{children:"Turning maneuvers"}),"\n",(0,i.jsx)(e.li,{children:"Walking on uneven terrain"}),"\n",(0,i.jsx)(e.li,{children:"Disturbance rejection (external pushes)"}),"\n",(0,i.jsx)(e.li,{children:"Stair climbing (simulation)"}),"\n",(0,i.jsx)(e.li,{children:"Obstacle avoidance while walking"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"Evaluate the system's performance using the metrics discussed in this section."})]})}function p(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(_,{...n})}):_(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>a,x:()=>s});var o=t(6540);const i={},r=o.createContext(i);function a(n){const e=o.useContext(r);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:a(n.components),o.createElement(r.Provider,{value:e},n.children)}}}]);