"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[91],{2104:(i,n,e)=>{e.r(n),e.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>t,metadata:()=>o,toc:()=>a});const o=JSON.parse('{"id":"module-2-digital-twin/physics-collisions","title":"Physics and Collisions","description":"Understanding physics and collision properties is crucial for creating realistic digital twins. This section covers the principles of physics simulation and collision detection in both Gazebo and Unity environments.","source":"@site/docs/module-2-digital-twin/physics-collisions.md","sourceDirName":"module-2-digital-twin","slug":"/module-2-digital-twin/physics-collisions","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/module-2-digital-twin/physics-collisions","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Gazebo World Setup and Configuration","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/module-2-digital-twin/gazebo-world-setup"},"next":{"title":"Practical Exercises - Digital Twin Simulation","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/module-2-digital-twin/practical-exercises"}}');var s=e(4848),l=e(8453);const t={},r="Physics and Collisions",c={},a=[{value:"Physics Simulation Fundamentals",id:"physics-simulation-fundamentals",level:2},{value:"Physics in Gazebo",id:"physics-in-gazebo",level:2},{value:"Physics Engines",id:"physics-engines",level:3},{value:"Physics Configuration",id:"physics-configuration",level:3},{value:"Material Properties",id:"material-properties",level:3},{value:"Inertial Properties",id:"inertial-properties",level:3},{value:"Collision Detection in Gazebo",id:"collision-detection-in-gazebo",level:2},{value:"Collision Geometries",id:"collision-geometries",level:3},{value:"Collision Filtering",id:"collision-filtering",level:3},{value:"Physics in Unity",id:"physics-in-unity",level:2},{value:"Physics Engine",id:"physics-engine",level:3},{value:"Rigidbody Configuration",id:"rigidbody-configuration",level:3},{value:"Collider Configuration",id:"collider-configuration",level:3},{value:"Joint Configuration",id:"joint-configuration",level:3},{value:"Physics Materials",id:"physics-materials",level:3},{value:"Collision Events",id:"collision-events",level:2},{value:"Unity Collision Detection",id:"unity-collision-detection",level:3},{value:"Advanced Physics Concepts",id:"advanced-physics-concepts",level:2},{value:"Continuous Collision Detection",id:"continuous-collision-detection",level:3},{value:"Layer-based Collision Matrix",id:"layer-based-collision-matrix",level:3},{value:"Force Application",id:"force-application",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Gazebo Optimization",id:"gazebo-optimization",level:3},{value:"Unity Optimization",id:"unity-optimization",level:3},{value:"Debugging Physics",id:"debugging-physics",level:2},{value:"Visualization Tools",id:"visualization-tools",level:3},{value:"Common Issues",id:"common-issues",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Exercise",id:"exercise",level:2}];function d(i){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...i.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"physics-and-collisions",children:"Physics and Collisions"})}),"\n",(0,s.jsx)(n.p,{children:"Understanding physics and collision properties is crucial for creating realistic digital twins. This section covers the principles of physics simulation and collision detection in both Gazebo and Unity environments."}),"\n",(0,s.jsx)(n.h2,{id:"physics-simulation-fundamentals",children:"Physics Simulation Fundamentals"}),"\n",(0,s.jsx)(n.p,{children:"Physics simulation in robotics environments involves modeling real-world physical behaviors:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Rigid Body Dynamics"}),": Movement and interaction of solid objects"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Collision Detection"}),": Identifying when objects intersect"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Contact Response"}),": Calculating forces when objects touch"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Constraints"}),": Joints and connections between parts"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"physics-in-gazebo",children:"Physics in Gazebo"}),"\n",(0,s.jsx)(n.h3,{id:"physics-engines",children:"Physics Engines"}),"\n",(0,s.jsx)(n.p,{children:"Gazebo supports multiple physics engines:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ODE (Open Dynamics Engine)"}),": Default, good balance of speed and accuracy"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Bullet"}),": Fast and robust, good for complex interactions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Simbody"}),": Highly accurate, suitable for biomechanics"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"DART"}),": Advanced constraint handling"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"physics-configuration",children:"Physics Configuration"}),"\n",(0,s.jsx)(n.p,{children:"In world files, configure physics properties:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<physics type="ode">\n  <max_step_size>0.001</max_step_size>  \x3c!-- Time step for simulation --\x3e\n  <real_time_factor>1</real_time_factor> \x3c!-- Simulation speed vs real time --\x3e\n  <real_time_update_rate>1000</real_time_update_rate> \x3c!-- Hz --\x3e\n\n  \x3c!-- Gravity --\x3e\n  <gravity>0 0 -9.8</gravity>\n\n  \x3c!-- ODE-specific parameters --\x3e\n  <ode>\n    <solver>\n      <type>quick</type>  \x3c!-- or "pgs" --\x3e\n      <iters>10</iters>\n      <sor>1.3</sor>\n    </solver>\n    <constraints>\n      <cfm>0</cfm>\n      <erp>0.2</erp>\n      <contact_max_correcting_vel>100</contact_max_correcting_vel>\n      <contact_surface_layer>0.001</contact_surface_layer>\n    </constraints>\n  </ode>\n</physics>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"material-properties",children:"Material Properties"}),"\n",(0,s.jsx)(n.p,{children:"Define material properties for realistic interactions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<link name="link_with_materials">\n  <collision name="collision">\n    <geometry>\n      <box><size>0.1 0.1 0.1</size></box>\n    </geometry>\n    <surface>\n      <friction>\n        <ode>\n          <mu>0.5</mu>      \x3c!-- Static friction coefficient --\x3e\n          <mu2>0.5</mu2>    \x3c!-- Secondary friction coefficient --\x3e\n          <slip1>0.0</slip1> \x3c!-- Primary slip coefficient --\x3e\n          <slip2>0.0</slip2> \x3c!-- Secondary slip coefficient --\x3e\n        </ode>\n      </friction>\n      <bounce>\n        <restitution_coefficient>0.1</restitution_coefficient>\n        <threshold>100000</threshold>\n      </bounce>\n      <contact>\n        <ode>\n          <max_vel>100</max_vel>\n          <min_depth>0.001</min_depth>\n        </ode>\n      </contact>\n    </surface>\n  </collision>\n</link>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"inertial-properties",children:"Inertial Properties"}),"\n",(0,s.jsx)(n.p,{children:"Proper inertial properties are essential for realistic simulation:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:"<inertial>\n  <mass>1.0</mass>\n  <inertia>\n    <ixx>0.0833333</ixx>\n    <ixy>0.0</ixy>\n    <ixz>0.0</ixz>\n    <iyy>0.0833333</iyy>\n    <iyz>0.0</iyz>\n    <izz>0.0833333</izz>\n  </inertia>\n</inertial>\n"})}),"\n",(0,s.jsx)(n.p,{children:"For a box with mass m and dimensions (x, y, z):"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"ixx = m*(y\xb2 + z\xb2)/12"}),"\n",(0,s.jsx)(n.li,{children:"iyy = m*(x\xb2 + z\xb2)/12"}),"\n",(0,s.jsx)(n.li,{children:"izz = m*(x\xb2 + y\xb2)/12"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"collision-detection-in-gazebo",children:"Collision Detection in Gazebo"}),"\n",(0,s.jsx)(n.h3,{id:"collision-geometries",children:"Collision Geometries"}),"\n",(0,s.jsx)(n.p,{children:"Gazebo supports various collision geometries:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Box"}),": Rectangular prism"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cylinder"}),": Cylindrical shape"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Sphere"}),": Spherical shape"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Mesh"}),": Complex shapes from 3D models"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Plane"}),": Infinite flat surface"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<collision name="collision_box">\n  <geometry>\n    <box><size>0.1 0.2 0.3</size></box>\n  </geometry>\n</collision>\n\n<collision name="collision_cylinder">\n  <geometry>\n    <cylinder>\n      <radius>0.05</radius>\n      <length>0.1</length>\n    </cylinder>\n  </geometry>\n</collision>\n\n<collision name="collision_sphere">\n  <geometry>\n    <sphere><radius>0.05</radius></sphere>\n  </geometry>\n</collision>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"collision-filtering",children:"Collision Filtering"}),"\n",(0,s.jsx)(n.p,{children:"Use collision groups and masks to control which objects can collide:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<collision name="collision_with_filter">\n  <surface>\n    <contact>\n      <collide_without_contact>false</collide_without_contact>\n    </contact>\n  </surface>\n</collision>\n'})}),"\n",(0,s.jsx)(n.h2,{id:"physics-in-unity",children:"Physics in Unity"}),"\n",(0,s.jsx)(n.h3,{id:"physics-engine",children:"Physics Engine"}),"\n",(0,s.jsx)(n.p,{children:"Unity uses NVIDIA PhysX for physics simulation, which provides:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Advanced collision detection"}),"\n",(0,s.jsx)(n.li,{children:"Realistic contact response"}),"\n",(0,s.jsx)(n.li,{children:"Vehicle dynamics"}),"\n",(0,s.jsx)(n.li,{children:"Cloth simulation"}),"\n",(0,s.jsx)(n.li,{children:"Soft body dynamics"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"rigidbody-configuration",children:"Rigidbody Configuration"}),"\n",(0,s.jsx)(n.p,{children:"Each physical object needs a Rigidbody component:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'using UnityEngine;\n\npublic class PhysicsObject : MonoBehaviour\n{\n    [Header("Physics Properties")]\n    public float mass = 1.0f;\n    public Vector3 centerOfMass = Vector3.zero;\n    public Vector3 inertiaTensor = Vector3.one;\n    public float drag = 0.0f;\n    public float angularDrag = 0.05f;\n\n    [Header("Collision Properties")]\n    public bool useGravity = true;\n    public bool isKinematic = false;\n\n    private Rigidbody rb;\n\n    void Start()\n    {\n        rb = GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            rb.mass = mass;\n            rb.centerOfMass = centerOfMass;\n            rb.inertiaTensor = inertiaTensor;\n            rb.drag = drag;\n            rb.angularDrag = angularDrag;\n            rb.useGravity = useGravity;\n            rb.isKinematic = isKinematic;\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"collider-configuration",children:"Collider Configuration"}),"\n",(0,s.jsx)(n.p,{children:"Unity supports various collider types:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// Box Collider\n[RequireComponent(typeof(Rigidbody))]\npublic class BoxColliderSetup : MonoBehaviour\n{\n    [SerializeField] private Vector3 size = Vector3.one;\n    [SerializeField] private Vector3 center = Vector3.zero;\n    [SerializeField] private bool isTrigger = false;\n\n    void Start()\n    {\n        BoxCollider boxCollider = gameObject.AddComponent<BoxCollider>();\n        boxCollider.size = size;\n        boxCollider.center = center;\n        boxCollider.isTrigger = isTrigger;\n    }\n}\n\n// Mesh Collider\n[RequireComponent(typeof(Rigidbody))]\npublic class MeshColliderSetup : MonoBehaviour\n{\n    [SerializeField] private bool convex = false;\n    [SerializeField] private bool inflateMesh = false;\n\n    void Start()\n    {\n        MeshCollider meshCollider = gameObject.AddComponent<MeshCollider>();\n        meshCollider.convex = convex;\n        meshCollider.inflateMesh = inflateMesh;\n\n        // Use the mesh from a MeshFilter component\n        MeshFilter meshFilter = GetComponent<MeshFilter>();\n        if (meshFilter != null)\n        {\n            meshCollider.sharedMesh = meshFilter.sharedMesh;\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"joint-configuration",children:"Joint Configuration"}),"\n",(0,s.jsx)(n.p,{children:"Unity provides various joint types for connecting rigidbodies:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// Hinge Joint Example\npublic class HingeJointSetup : MonoBehaviour\n{\n    [SerializeField] private float motorForce = 10f;\n    [SerializeField] private float targetVelocity = 0f;\n    [SerializeField] private bool useMotor = false;\n\n    void Start()\n    {\n        HingeJoint hinge = GetComponent<HingeJoint>();\n\n        // Configure motor\n        JointMotor motor = hinge.motor;\n        motor.force = motorForce;\n        motor.targetVelocity = targetVelocity;\n        motor.freeSpin = false;\n        hinge.motor = motor;\n        hinge.useMotor = useMotor;\n\n        // Configure limits\n        JointLimits limits = hinge.limits;\n        limits.min = -90f;  // Minimum angle in degrees\n        limits.max = 90f;   // Maximum angle in degrees\n        hinge.limits = limits;\n        hinge.useLimits = true;\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"physics-materials",children:"Physics Materials"}),"\n",(0,s.jsx)(n.p,{children:"Create realistic surface interactions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'// Create a physics material in code\npublic class PhysicsMaterialSetup : MonoBehaviour\n{\n    [SerializeField] private float staticFriction = 0.5f;\n    [SerializeField] private float dynamicFriction = 0.4f;\n    [SerializeField] private float bounciness = 0.1f;\n    [SerializeField] private PhysicMaterialCombine frictionCombine = PhysicMaterialCombine.Average;\n    [SerializeField] private PhysicMaterialCombine bounceCombine = PhysicMaterialCombine.Average;\n\n    void Start()\n    {\n        PhysicMaterial material = new PhysicMaterial("CustomMaterial");\n        material.staticFriction = staticFriction;\n        material.dynamicFriction = dynamicFriction;\n        material.bounciness = bounciness;\n        material.frictionCombine = frictionCombine;\n        material.bounceCombine = bounceCombine;\n\n        Collider col = GetComponent<Collider>();\n        if (col != null)\n        {\n            col.material = material;\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"collision-events",children:"Collision Events"}),"\n",(0,s.jsx)(n.h3,{id:"unity-collision-detection",children:"Unity Collision Detection"}),"\n",(0,s.jsx)(n.p,{children:"Handle collision events in Unity:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'using UnityEngine;\n\npublic class CollisionHandler : MonoBehaviour\n{\n    void OnCollisionEnter(Collision collision)\n    {\n        Debug.Log($"Collision with {collision.gameObject.name}");\n\n        foreach (ContactPoint contact in collision.contacts)\n        {\n            Debug.DrawRay(contact.point, contact.normal, Color.white);\n            Debug.Log($"Contact point: {contact.point}");\n            Debug.Log($"Contact force: {collision.impulse}");\n        }\n    }\n\n    void OnCollisionStay(Collision collision)\n    {\n        // Called each frame while colliding\n        foreach (ContactPoint contact in collision.contacts)\n        {\n            Debug.Log($"Contact force: {contact.force}");\n        }\n    }\n\n    void OnCollisionExit(Collision collision)\n    {\n        Debug.Log($"Collision ended with {collision.gameObject.name}");\n    }\n\n    // Trigger events (for isTrigger colliders)\n    void OnTriggerEnter(Collider other)\n    {\n        Debug.Log($"Trigger entered: {other.name}");\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"advanced-physics-concepts",children:"Advanced Physics Concepts"}),"\n",(0,s.jsx)(n.h3,{id:"continuous-collision-detection",children:"Continuous Collision Detection"}),"\n",(0,s.jsx)(n.p,{children:"For fast-moving objects to prevent tunneling:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"void Start()\n{\n    Rigidbody rb = GetComponent<Rigidbody>();\n    if (rb != null)\n    {\n        // Use continuous collision detection for fast objects\n        rb.collisionDetectionMode = CollisionDetectionMode.Continuous;\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"layer-based-collision-matrix",children:"Layer-based Collision Matrix"}),"\n",(0,s.jsx)(n.p,{children:"Control which layers can collide with each other in Unity:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Edit \u2192 Project Settings \u2192 Physics"}),"\n",(0,s.jsx)(n.li,{children:"Configure the collision matrix for different layers"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"force-application",children:"Force Application"}),"\n",(0,s.jsx)(n.p,{children:"Apply forces to simulate realistic interactions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public class ForceApplication : MonoBehaviour\n{\n    [SerializeField] private float forceMagnitude = 10f;\n    [SerializeField] private ForceMode forceMode = ForceMode.Force;\n\n    public void ApplyForce(Vector3 direction)\n    {\n        Rigidbody rb = GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            rb.AddForce(direction * forceMagnitude, forceMode);\n        }\n    }\n\n    public void ApplyTorque(Vector3 torque)\n    {\n        Rigidbody rb = GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            rb.AddTorque(torque * forceMagnitude, forceMode);\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,s.jsx)(n.h3,{id:"gazebo-optimization",children:"Gazebo Optimization"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use simpler collision geometries when possible"}),"\n",(0,s.jsx)(n.li,{children:"Adjust physics update rates for performance vs accuracy"}),"\n",(0,s.jsx)(n.li,{children:"Use fixed joints instead of complex constraint systems"}),"\n",(0,s.jsx)(n.li,{children:"Limit the number of active objects in simulation"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"unity-optimization",children:"Unity Optimization"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use convex mesh colliders for dynamic objects"}),"\n",(0,s.jsx)(n.li,{children:"Use compound colliders for complex shapes"}),"\n",(0,s.jsx)(n.li,{children:"Adjust solver iteration counts for performance"}),"\n",(0,s.jsx)(n.li,{children:"Use object pooling for frequently created/destroyed objects"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"debugging-physics",children:"Debugging Physics"}),"\n",(0,s.jsx)(n.h3,{id:"visualization-tools",children:"Visualization Tools"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Enable physics visualization in both Gazebo and Unity"}),"\n",(0,s.jsx)(n.li,{children:"Use debug drawing to visualize collision shapes"}),"\n",(0,s.jsx)(n.li,{children:"Monitor simulation statistics and performance metrics"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"common-issues",children:"Common Issues"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Tunneling"}),": Objects passing through each other (fix with CCD)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Jittering"}),": Unstable contact points (fix with proper mass ratios)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Penetration"}),": Objects sinking into each other (fix with proper solver settings)"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use realistic mass properties (don't make everything 1kg)"}),"\n",(0,s.jsx)(n.li,{children:"Configure friction coefficients based on real materials"}),"\n",(0,s.jsx)(n.li,{children:"Test with extreme values to ensure stability"}),"\n",(0,s.jsx)(n.li,{children:"Balance accuracy with performance requirements"}),"\n",(0,s.jsx)(n.li,{children:"Validate simulation results against real-world data when possible"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"exercise",children:"Exercise"}),"\n",(0,s.jsx)(n.p,{children:"Create a simulation scene with multiple objects of different materials and masses. Implement collision detection that triggers different behaviors based on collision forces. Test the scene with different physics configurations to observe the effects on stability and realism."})]})}function h(i={}){const{wrapper:n}={...(0,l.R)(),...i.components};return n?(0,s.jsx)(n,{...i,children:(0,s.jsx)(d,{...i})}):d(i)}},8453:(i,n,e)=>{e.d(n,{R:()=>t,x:()=>r});var o=e(6540);const s={},l=o.createContext(s);function t(i){const n=o.useContext(l);return o.useMemo(function(){return"function"==typeof i?i(n):{...n,...i}},[n,i])}function r(i){let n;return n=i.disableParentContext?"function"==typeof i.components?i.components(s):i.components||s:t(i.components),o.createElement(l.Provider,{value:n},i.children)}}}]);