"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[612],{76:(n,e,o)=>{o.r(e),o.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"module-3-ai-perception/nav2-locomotion","title":"Nav2 for Humanoid Locomotion","description":"Navigation 2 (Nav2) is the ROS 2 navigation stack that enables autonomous navigation for robots. For humanoid robots, Nav2 requires special configuration to handle the unique challenges of bipedal locomotion. This section covers configuring and using Nav2 for humanoid robot navigation.","source":"@site/docs/module-3-ai-perception/nav2-locomotion.md","sourceDirName":"module-3-ai-perception","slug":"/module-3-ai-perception/nav2-locomotion","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/module-3-ai-perception/nav2-locomotion","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Navigation Planning and Obstacle Avoidance Examples","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/module-3-ai-perception/navigation-planning-obstacle-avoidance"},"next":{"title":"Perception and Navigation Pipeline Diagrams","permalink":"/Physical-AI-Humanoid-Robotics-Book/docs/module-3-ai-perception/perception-navigation-pipeline-diagrams"}}');var t=o(4848),i=o(8453);const s={},r="Nav2 for Humanoid Locomotion",l={},c=[{value:"Introduction to Nav2",id:"introduction-to-nav2",level:2},{value:"Nav2 Architecture",id:"nav2-architecture",level:2},{value:"Core Components",id:"core-components",level:3},{value:"Humanoid-Specific Considerations",id:"humanoid-specific-considerations",level:3},{value:"Nav2 Configuration for Humanoid Robots",id:"nav2-configuration-for-humanoid-robots",level:2},{value:"Basic Parameters Configuration",id:"basic-parameters-configuration",level:3},{value:"Humanoid-Specific Navigation Challenges",id:"humanoid-specific-navigation-challenges",level:2},{value:"1. Bipedal Dynamics",id:"1-bipedal-dynamics",level:3},{value:"2. Step Planning",id:"2-step-planning",level:3},{value:"3. Balance Controller",id:"3-balance-controller",level:3},{value:"Nav2 Launch Configuration",id:"nav2-launch-configuration",level:2},{value:"Complete Launch File",id:"complete-launch-file",level:3},{value:"Custom Controllers for Humanoid Robots",id:"custom-controllers-for-humanoid-robots",level:2},{value:"Humanoid Path Following Controller",id:"humanoid-path-following-controller",level:3},{value:"Integration with Isaac Sim",id:"integration-with-isaac-sim",level:2},{value:"Isaac Sim Navigation Setup",id:"isaac-sim-navigation-setup",level:3},{value:"Performance Evaluation",id:"performance-evaluation",level:2},{value:"Navigation Metrics for Humanoid Robots",id:"navigation-metrics-for-humanoid-robots",level:3},{value:"Troubleshooting Navigation Issues",id:"troubleshooting-navigation-issues",level:2},{value:"Common Problems and Solutions",id:"common-problems-and-solutions",level:3},{value:"1. Robot Gets Stuck",id:"1-robot-gets-stuck",level:4},{value:"2. Poor Path Quality",id:"2-poor-path-quality",level:4},{value:"3. Balance Issues During Navigation",id:"3-balance-issues-during-navigation",level:4},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Parameter Tuning",id:"1-parameter-tuning",level:3},{value:"2. Safety Considerations",id:"2-safety-considerations",level:3},{value:"3. Performance Optimization",id:"3-performance-optimization",level:3},{value:"Exercise",id:"exercise",level:2}];function _(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"nav2-for-humanoid-locomotion",children:"Nav2 for Humanoid Locomotion"})}),"\n",(0,t.jsx)(e.p,{children:"Navigation 2 (Nav2) is the ROS 2 navigation stack that enables autonomous navigation for robots. For humanoid robots, Nav2 requires special configuration to handle the unique challenges of bipedal locomotion. This section covers configuring and using Nav2 for humanoid robot navigation."}),"\n",(0,t.jsx)(e.h2,{id:"introduction-to-nav2",children:"Introduction to Nav2"}),"\n",(0,t.jsx)(e.p,{children:"Nav2 is a complete navigation system that includes:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Global Planner"}),": Plans path from start to goal"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Local Planner"}),": Executes path while avoiding obstacles"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Controller"}),": Sends commands to robot actuators"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Costmaps"}),": Represents obstacles and free space"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Behavior Trees"}),": Orchestrates navigation behaviors"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Recovery Behaviors"}),": Handles navigation failures"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"nav2-architecture",children:"Nav2 Architecture"}),"\n",(0,t.jsx)(e.h3,{id:"core-components",children:"Core Components"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Nav2 System\n\u251c\u2500\u2500 Navigation Server\n\u2502   \u251c\u2500\u2500 Global Planner (NavFn, A*, etc.)\n\u2502   \u251c\u2500\u2500 Local Planner (DWA, TEB, etc.)\n\u2502   \u2514\u2500\u2500 Controller (PID, MPC, etc.)\n\u251c\u2500\u2500 Costmap Server\n\u2502   \u251c\u2500\u2500 Global Costmap\n\u2502   \u2514\u2500\u2500 Local Costmap\n\u251c\u2500\u2500 Lifecycle Manager\n\u251c\u2500\u2500 Behavior Tree Navigator\n\u251c\u2500\u2500 Recovery Server\n\u2514\u2500\u2500 Transform Management (TF2)\n"})}),"\n",(0,t.jsx)(e.h3,{id:"humanoid-specific-considerations",children:"Humanoid-Specific Considerations"}),"\n",(0,t.jsx)(e.p,{children:"Humanoid robots require special handling in Nav2:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Bipedal dynamics"}),": Different from wheeled robots"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Balance constraints"}),": Must maintain center of mass"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Step planning"}),": Requires discrete foot placement"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Stair navigation"}),": Special locomotion patterns needed"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"nav2-configuration-for-humanoid-robots",children:"Nav2 Configuration for Humanoid Robots"}),"\n",(0,t.jsx)(e.h3,{id:"basic-parameters-configuration",children:"Basic Parameters Configuration"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:'# nav2_params_humanoid.yaml\namcl:\n  ros__parameters:\n    use_sim_time: True\n    alpha1: 0.2\n    alpha2: 0.2\n    alpha3: 0.2\n    alpha4: 0.2\n    alpha5: 0.2\n    base_frame_id: "base_link"\n    beam_skip_distance: 0.5\n    beam_skip_error_threshold: 0.9\n    beam_skip_threshold: 0.3\n    do_beamskip: false\n    global_frame_id: "map"\n    lambda_short: 0.1\n    laser_likelihood_max_dist: 2.0\n    laser_max_range: 100.0\n    laser_min_range: -1.0\n    laser_model_type: "likelihood_field"\n    max_beams: 60\n    max_particles: 2000\n    min_particles: 500\n    odom_frame_id: "odom"\n    pf_err: 0.05\n    pf_z: 0.99\n    recovery_alpha_fast: 0.0\n    recovery_alpha_slow: 0.0\n    resample_interval: 1\n    robot_model_type: "nav2_amcl::DifferentialMotionModel"  # This needs humanoid-specific model\n    save_pose_rate: 0.5\n    sigma_hit: 0.2\n    tf_broadcast: true\n    transform_tolerance: 1.0\n    update_min_a: 0.2\n    update_min_d: 0.2\n    z_hit: 0.5\n    z_max: 0.05\n    z_rand: 0.5\n    z_short: 0.05\n\namcl_map_client:\n  ros__parameters:\n    use_sim_time: True\n\namcl_rclcpp_node:\n  ros__parameters:\n    use_sim_time: True\n\nbt_navigator:\n  ros__parameters:\n    use_sim_time: True\n    global_frame: map\n    robot_base_frame: base_link\n    odom_topic: /odom\n    bt_loop_duration: 10\n    default_server_timeout: 20\n    enable_groot_monitoring: True\n    groot_zmq_publisher_port: 1666\n    groot_zmq_server_port: 1667\n    default_nav_through_poses_bt_xml: nav2_bt_navigator/navigate_through_poses_w_replanning_and_recovery.xml\n    default_nav_to_pose_bt_xml: nav2_bt_navigator/navigate_to_pose_w_replanning_and_recovery.xml\n    plugin_lib_names:\n    - nav2_compute_path_to_pose_action_bt_node\n    - nav2_compute_path_through_poses_action_bt_node\n    - nav2_smooth_path_action_bt_node\n    - nav2_follow_path_action_bt_node\n    - nav2_spin_action_bt_node\n    - nav2_wait_action_bt_node\n    - nav2_assisted_teleop_action_bt_node\n    - nav2_back_up_action_bt_node\n    - nav2_drive_on_heading_bt_node\n    - nav2_clear_costmap_service_bt_node\n    - nav2_is_stuck_condition_bt_node\n    - nav2_goal_reached_condition_bt_node\n    - nav2_goal_updated_condition_bt_node\n    - nav2_globally_consistent_condition_bt_node\n    - nav2_is_path_valid_condition_bt_node\n    - nav2_initial_pose_received_condition_bt_node\n    - nav2_reinitialize_global_localization_service_bt_node\n    - nav2_rate_controller_bt_node\n    - nav2_distance_controller_bt_node\n    - nav2_speed_controller_bt_node\n    - nav2_truncate_path_action_bt_node\n    - nav2_truncate_path_local_action_bt_node\n    - nav2_goal_updater_node_bt_node\n    - nav2_recovery_node_bt_node\n    - nav2_pipeline_sequence_bt_node\n    - nav2_round_robin_node_bt_node\n    - nav2_transform_available_condition_bt_node\n    - nav2_time_expired_condition_bt_node\n    - nav2_path_expiring_timer_condition\n    - nav2_distance_traveled_condition_bt_node\n    - nav2_is_battery_low_condition_bt_node\n    - nav2_navigate_through_poses_action_bt_node\n    - nav2_navigate_to_pose_action_bt_node\n    - nav2_remove_passed_goals_action_bt_node\n    - nav2_planner_selector_bt_node\n    - nav2_controller_selector_bt_node\n    - nav2_goal_checker_selector_bt_node\n    - nav2_controller_cancel_bt_node\n    - nav2_path_longer_on_approach_bt_node\n    - nav2_wait_cancel_bt_node\n    - nav2_spin_cancel_bt_node\n    - nav2_back_up_cancel_bt_node\n    - nav2_assisted_teleop_cancel_bt_node\n    - nav2_drive_on_heading_cancel_bt_node\n\nbt_navigator_rclcpp_node:\n  ros__parameters:\n    use_sim_time: True\n\ncontroller_server:\n  ros__parameters:\n    use_sim_time: True\n    controller_frequency: 20.0\n    min_x_velocity_threshold: 0.001\n    min_y_velocity_threshold: 0.5\n    min_theta_velocity_threshold: 0.001\n    progress_checker_plugin: "progress_checker"\n    goal_checker_plugin: "goal_checker"\n    controller_plugins: ["FollowPath"]\n\n    # Humanoid-specific controller\n    FollowPath:\n      plugin: "nav2_mppi_controller::MppiController"  # Or custom humanoid controller\n      time_steps: 20\n      control_frequency: 10.0\n      motion_model: "DiffDrive"  # Need humanoid-specific model\n      xy_goal_tolerance: 0.25\n      yaw_goal_tolerance: 0.25\n      state_bounds_planner: 0.3\n      control_bounds_planner: 0.5\n      control_bounds: 1.0\n      state_bounds: 0.5\n      dt: 0.05\n      noise_coefficient: 0.0\n      convergence_integrator_gain: 0.1\n      oscillation_threshold: 0.01\n      oscillation_window: 10\n\ncontroller_server_rclcpp_node:\n  ros__parameters:\n    use_sim_time: True\n\nlocal_costmap:\n  local_costmap:\n    ros__parameters:\n      update_frequency: 5.0\n      publish_frequency: 2.0\n      global_frame: odom\n      robot_base_frame: base_link\n      use_sim_time: True\n      rolling_window: true\n      width: 6\n      height: 6\n      resolution: 0.05\n      robot_radius: 0.3  # Adjust for humanoid robot size\n      plugins: ["voxel_layer", "inflation_layer"]\n      inflation_layer:\n        plugin: "nav2_costmap_2d::InflationLayer"\n        cost_scaling_factor: 3.0\n        inflation_radius: 0.55\n      voxel_layer:\n        plugin: "nav2_costmap_2d::VoxelLayer"\n        enabled: True\n        publish_voxel_map: True\n        origin_z: 0.0\n        z_resolution: 0.2\n        z_voxels: 8\n        max_obstacle_height: 2.0\n        mark_threshold: 0\n        observation_sources: scan\n        scan:\n          topic: /scan\n          max_obstacle_height: 2.0\n          clearing: True\n          marking: True\n          data_type: "LaserScan"\n          raytrace_max_range: 3.0\n          raytrace_min_range: 0.0\n          obstacle_max_range: 2.5\n          obstacle_min_range: 0.0\n  local_costmap_client:\n    ros__parameters:\n      use_sim_time: True\n  local_costmap_rclcpp_node:\n    ros__parameters:\n      use_sim_time: True\n\nglobal_costmap:\n  global_costmap:\n    ros__parameters:\n      update_frequency: 1.0\n      publish_frequency: 1.0\n      global_frame: map\n      robot_base_frame: base_link\n      use_sim_time: True\n      robot_radius: 0.3  # Adjust for humanoid robot\n      resolution: 0.05\n      track_unknown_space: true\n      plugins: ["static_layer", "obstacle_layer", "inflation_layer"]\n      obstacle_layer:\n        plugin: "nav2_costmap_2d::ObstacleLayer"\n        enabled: True\n        observation_sources: scan\n        scan:\n          topic: /scan\n          max_obstacle_height: 2.0\n          clearing: True\n          marking: True\n          data_type: "LaserScan"\n          raytrace_max_range: 3.0\n          raytrace_min_range: 0.0\n          obstacle_max_range: 2.5\n          obstacle_min_range: 0.0\n      static_layer:\n        plugin: "nav2_costmap_2d::StaticLayer"\n        map_subscribe_transient_local: True\n      inflation_layer:\n        plugin: "nav2_costmap_2d::InflationLayer"\n        cost_scaling_factor: 3.0\n        inflation_radius: 0.55\n  global_costmap_client:\n    ros__parameters:\n      use_sim_time: True\n  global_costmap_rclcpp_node:\n    ros__parameters:\n      use_sim_time: True\n\nmap_server:\n  ros__parameters:\n    use_sim_time: True\n    yaml_filename: "turtlebot3_world.yaml"\n\nmap_saver:\n  ros__parameters:\n    use_sim_time: True\n    save_map_timeout: 5.0\n    free_thresh_default: 0.25\n    occupied_thresh_default: 0.65\n\nplanner_server:\n  ros__parameters:\n    use_sim_time: True\n    planner_plugins: ["GridBased"]\n    GridBased:\n      plugin: "nav2_navfn_planner::NavfnPlanner"\n      tolerance: 0.5\n      use_astar: false\n      allow_unknown: true\n\nplanner_server_rclcpp_node:\n  ros__parameters:\n    use_sim_time: True\n\nrecoveries_server:\n  ros__parameters:\n    use_sim_time: True\n    recovery_plugins: ["spin", "backup", "wait"]\n    spin:\n      plugin: "nav2_recoveries::Spin"\n      ideal_linear_velocity: 0.0\n      ideal_angular_velocity: 1.0\n      tolerance: 1.57\n      sampling_frequency: 20.0\n      cmd_vel_timeout: 1.0\n    backup:\n      plugin: "nav2_recoveries::BackUp"\n      ideal_linear_velocity: -0.1\n      ideal_angular_velocity: 0.0\n      tolerance: 0.15\n      sampling_frequency: 10.0\n      cmd_vel_timeout: 1.0\n    wait:\n      plugin: "nav2_recoveries::Wait"\n      sleep_duration: 2.0\n      sampling_frequency: 10.0\n      cmd_vel_timeout: 1.0\n\nrobot_state_publisher:\n  ros__parameters:\n    use_sim_time: True\n'})}),"\n",(0,t.jsx)(e.h2,{id:"humanoid-specific-navigation-challenges",children:"Humanoid-Specific Navigation Challenges"}),"\n",(0,t.jsx)(e.h3,{id:"1-bipedal-dynamics",children:"1. Bipedal Dynamics"}),"\n",(0,t.jsx)(e.p,{children:"Humanoid robots have different locomotion characteristics:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"// Humanoid motion model for navigation\nclass HumanoidMotionModel\n{\npublic:\n    HumanoidMotionModel()\n    {\n        // Humanoid-specific parameters\n        step_length_ = 0.3;      // Average step length\n        step_duration_ = 0.8;    // Time for one step\n        max_step_width_ = 0.2;   // Maximum lateral step\n        balance_margin_ = 0.1;   // Safety margin for balance\n    }\n\n    geometry_msgs::msg::Pose predictPose(\n        const geometry_msgs::msg::Pose& current_pose,\n        const geometry_msgs::msg::Twist& cmd_vel,\n        double dt)\n    {\n        // Implement humanoid-specific motion prediction\n        // Consider step-by-step locomotion instead of continuous motion\n        geometry_msgs::msg::Pose predicted_pose = current_pose;\n\n        // Calculate step-based movement\n        double steps = dt / step_duration_;\n        double step_dx = cmd_vel.linear.x * step_duration_;\n        double step_dy = cmd_vel.linear.y * step_duration_;\n        double step_dtheta = cmd_vel.angular.z * step_duration_;\n\n        // Apply step constraints\n        step_dx = std::min(step_dx, step_length_);\n        step_dy = std::min(step_dy, max_step_width_);\n\n        // Update pose based on steps\n        predicted_pose.position.x += step_dx * steps;\n        predicted_pose.position.y += step_dy * steps;\n\n        // Update orientation\n        tf2::Quaternion q(\n            predicted_pose.orientation.x,\n            predicted_pose.orientation.y,\n            predicted_pose.orientation.z,\n            predicted_pose.orientation.w\n        );\n        tf2::Matrix3x3 m(q);\n        double roll, pitch, yaw;\n        m.getRPY(roll, pitch, yaw);\n        yaw += step_dtheta * steps;\n\n        // Convert back to quaternion\n        q.setRPY(roll, pitch, yaw);\n        predicted_pose.orientation.x = q.x();\n        predicted_pose.orientation.y = q.y();\n        predicted_pose.orientation.z = q.z();\n        predicted_pose.orientation.w = q.w();\n\n        return predicted_pose;\n    }\n\nprivate:\n    double step_length_;\n    double step_duration_;\n    double max_step_width_;\n    double balance_margin_;\n};\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-step-planning",children:"2. Step Planning"}),"\n",(0,t.jsx)(e.p,{children:"Humanoid robots need discrete step planning:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"// Step planner for humanoid navigation\nclass StepPlanner\n{\npublic:\n    struct Step\n    {\n        geometry_msgs::msg::Point left_foot;\n        geometry_msgs::msg::Point right_foot;\n        double time;\n    };\n\n    std::vector<Step> planSteps(\n        const geometry_msgs::msg::Pose& start,\n        const geometry_msgs::msg::Pose& goal,\n        const nav_msgs::msg::Path& global_path)\n    {\n        std::vector<Step> steps;\n\n        // Plan discrete steps along the path\n        // Ensure each step maintains balance\n        for (size_t i = 0; i < global_path.poses.size(); i += step_spacing_)\n        {\n            Step step;\n            step.left_foot = calculateLeftFootPosition(global_path.poses[i].pose);\n            step.right_foot = calculateRightFootPosition(global_path.poses[i].pose);\n            step.time = i * step_duration_;\n\n            // Verify step is balanced\n            if (isStepBalanced(step))\n            {\n                steps.push_back(step);\n            }\n        }\n\n        return steps;\n    }\n\nprivate:\n    bool isStepBalanced(const Step& step)\n    {\n        // Check if the step maintains center of mass within support polygon\n        geometry_msgs::msg::Point com = calculateCOM();\n        return isInSupportPolygon(com, step);\n    }\n\n    geometry_msgs::msg::Point calculateLeftFootPosition(const geometry_msgs::msg::Pose& pose);\n    geometry_msgs::msg::Point calculateRightFootPosition(const geometry_msgs::msg::Pose& pose);\n    geometry_msgs::msg::Point calculateCOM();\n    bool isInSupportPolygon(const geometry_msgs::msg::Point& com, const Step& step);\n\n    size_t step_spacing_ = 2;  // Plan every 2nd point from path\n    double step_duration_ = 0.8;\n};\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-balance-controller",children:"3. Balance Controller"}),"\n",(0,t.jsx)(e.p,{children:"Maintain balance during navigation:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"// Balance controller for humanoid navigation\nclass BalanceController\n{\npublic:\n    BalanceController()\n    {\n        // Initialize balance control parameters\n        com_height_ = 0.8;  // Height of center of mass\n        control_frequency_ = 100.0;  // Balance control frequency\n    }\n\n    geometry_msgs::msg::Twist computeBalanceControl(\n        const geometry_msgs::msg::Pose& current_pose,\n        const geometry_msgs::msg::Twist& desired_twist)\n    {\n        geometry_msgs::msg::Twist balance_twist = desired_twist;\n\n        // Calculate center of mass position and velocity\n        geometry_msgs::msg::Point com = calculateCOM();\n        geometry_msgs::msg::Vector3 com_vel = calculateCOMVelocity();\n\n        // Calculate Zero Moment Point (ZMP)\n        geometry_msgs::msg::Point zmp = calculateZMP(com, com_vel);\n\n        // Calculate balance error\n        double balance_error_x = zmp.x - desired_zmp_.x;\n        double balance_error_y = zmp.y - desired_zmp_.y;\n\n        // Apply balance correction using PID control\n        balance_twist.linear.x += balance_pid_x_.compute(balance_error_x);\n        balance_twist.linear.y += balance_pid_y_.compute(balance_error_y);\n\n        // Limit corrections to maintain stability\n        balance_twist.linear.x = std::clamp(balance_twist.linear.x, -0.1, 0.1);\n        balance_twist.linear.y = std::clamp(balance_twist.linear.y, -0.05, 0.05);\n\n        return balance_twist;\n    }\n\nprivate:\n    geometry_msgs::msg::Point calculateCOM();\n    geometry_msgs::msg::Vector3 calculateCOMVelocity();\n    geometry_msgs::msg::Point calculateZMP(\n        const geometry_msgs::msg::Point& com,\n        const geometry_msgs::msg::Vector3& com_vel);\n\n    geometry_msgs::msg::Point desired_zmp_;\n    double com_height_;\n    double control_frequency_;\n\n    // PID controllers for balance\n    PIDController balance_pid_x_;\n    PIDController balance_pid_y_;\n};\n"})}),"\n",(0,t.jsx)(e.h2,{id:"nav2-launch-configuration",children:"Nav2 Launch Configuration"}),"\n",(0,t.jsx)(e.h3,{id:"complete-launch-file",children:"Complete Launch File"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"# launch/humanoid_nav2.launch.py\nimport os\nfrom launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, SetEnvironmentVariable\nfrom launch.substitutions import LaunchConfiguration\nfrom launch_ros.actions import Node\nfrom ament_index_python.packages import get_package_share_directory\nfrom nav2_common.launch import RewrittenYaml\n\n\ndef generate_launch_description():\n    # Get the launch directory\n    package_dir = get_package_share_directory('humanoid_navigation')\n\n    # Create the launch configuration variables\n    use_sim_time = LaunchConfiguration('use_sim_time')\n    autostart = LaunchConfiguration('autostart')\n    params_file = LaunchConfiguration('params_file')\n    bt_xml_filename = LaunchConfiguration('bt_xml_filename')\n    map_subscribe_transient_local = LaunchConfiguration('map_subscribe_transient_local')\n\n    # Declare the launch arguments\n    declare_use_sim_time = DeclareLaunchArgument(\n        'use_sim_time',\n        default_value='false',\n        description='Use simulation (Gazebo) clock if true')\n\n    declare_autostart = DeclareLaunchArgument(\n        'autostart',\n        default_value='true',\n        description='Automatically startup the nav2 stack')\n\n    declare_params_file = DeclareLaunchArgument(\n        'params_file',\n        default_value=os.path.join(package_dir, 'config', 'nav2_params_humanoid.yaml'),\n        description='Full path to the ROS2 parameters file to use for all launched nodes')\n\n    declare_bt_xml = DeclareLaunchArgument(\n        'bt_xml_filename',\n        default_value=os.path.join(\n            get_package_share_directory('nav2_bt_navigator'),\n            'behavior_trees', 'navigate_w_replanning_and_recovery.xml'),\n        description='Full path to the behavior tree xml file to use')\n\n    declare_map_subscribe_transient_local = DeclareLaunchArgument(\n        'map_subscribe_transient_local',\n        default_value='false',\n        description='Whether to set the map subscriber QoS to transient local')\n\n    # Make sure we have the right parameters file\n    param_substitutions = {\n        'use_sim_time': use_sim_time,\n        'autostart': autostart,\n        'bt_xml_filename': bt_xml_filename,\n        'map_subscribe_transient_local': map_subscribe_transient_local}\n\n    configured_params = RewrittenYaml(\n        source_file=params_file,\n        root_key='',\n        param_rewrites=param_substitutions,\n        convert_types=True)\n\n    # Specify the actions\n    lifecycle_nodes = ['controller_server',\n                       'planner_server',\n                       'recoveries_server',\n                       'bt_navigator',\n                       'waypoint_follower']\n\n    # Create the node\n    navigation_server = Node(\n        package='nav2_lifecycle_manager',\n        executable='lifecycle_manager',\n        name='lifecycle_manager_navigation',\n        output='screen',\n        parameters=[{'use_sim_time': use_sim_time},\n                    {'autostart': autostart},\n                    {'node_names': lifecycle_nodes}])\n\n    # Localization node (AMCL)\n    localization = Node(\n        package='nav2_amcl',\n        executable='amcl',\n        name='amcl',\n        output='screen',\n        parameters=[configured_params])\n\n    # Controller server\n    controller_server = Node(\n        package='nav2_controller',\n        executable='controller_server',\n        output='screen',\n        parameters=[configured_params])\n\n    # Planner server\n    planner_server = Node(\n        package='nav2_planner',\n        executable='planner_server',\n        name='planner_server',\n        output='screen',\n        parameters=[configured_params])\n\n    # BT navigator\n    bt_navigator = Node(\n        package='nav2_bt_navigator',\n        executable='bt_navigator',\n        name='bt_navigator',\n        output='screen',\n        parameters=[configured_params])\n\n    # Recovery server\n    recovery_server = Node(\n        package='nav2_recoveries',\n        executable='recoveries_server',\n        name='recoveries_server',\n        output='screen',\n        parameters=[configured_params])\n\n    # Waypoint follower\n    waypoint_follower = Node(\n        package='nav2_waypoint_follower',\n        executable='waypoint_follower',\n        name='waypoint_follower',\n        output='screen',\n        parameters=[configured_params])\n\n    # Add the actions to the launch description\n    ld = LaunchDescription()\n\n    # Declare the launch options\n    ld.add_action(declare_use_sim_time)\n    ld.add_action(declare_autostart)\n    ld.add_action(declare_params_file)\n    ld.add_action(declare_bt_xml)\n    ld.add_action(declare_map_subscribe_transient_local)\n\n    # Add the nodes to the launch description\n    ld.add_action(navigation_server)\n    ld.add_action(localization)\n    ld.add_action(controller_server)\n    ld.add_action(planner_server)\n    ld.add_action(bt_navigator)\n    ld.add_action(recovery_server)\n    ld.add_action(waypoint_follower)\n\n    return ld\n"})}),"\n",(0,t.jsx)(e.h2,{id:"custom-controllers-for-humanoid-robots",children:"Custom Controllers for Humanoid Robots"}),"\n",(0,t.jsx)(e.h3,{id:"humanoid-path-following-controller",children:"Humanoid Path Following Controller"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <nav2_core/controller.hpp>\n#include <nav2_util/lifecycle_node.hpp>\n#include <nav2_costmap_2d/costmap_2d_ros.hpp>\n#include <nav_msgs/msg/path.hpp>\n#include <geometry_msgs/msg/pose_stamped.hpp>\n#include <geometry_msgs/msg/twist.hpp>\n\nclass HumanoidController : public nav2_core::Controller\n{\npublic:\n    HumanoidController() = default;\n    ~HumanoidController() = default;\n\n    void configure(\n        const rclcpp_lifecycle::LifecycleNode::WeakPtr & parent,\n        std::string name,\n        const std::shared_ptr<tf2_ros::Buffer> & tf,\n        const std::shared_ptr<nav2_costmap_2d::Costmap2DROS> & costmap_ros) override\n    {\n        node_ = parent.lock();\n        name_ = name;\n        tf_ = tf;\n        costmap_ros_ = costmap_ros;\n        costmap_ = costmap_ros_->getCostmap();\n\n        // Initialize humanoid-specific parameters\n        step_frequency_ = node_->declare_parameter(name_ + ".step_frequency", 1.25);\n        max_step_length_ = node_->declare_parameter(name_ + ".max_step_length", 0.3);\n        balance_margin_ = node_->declare_parameter(name_ + ".balance_margin", 0.1);\n\n        RCLCPP_INFO(node_->get_logger(), "HumanoidController configured");\n    }\n\n    void cleanup() override\n    {\n        RCLCPP_INFO(node_->get_logger(), "HumanoidController cleaned up");\n    }\n\n    void activate() override\n    {\n        RCLCPP_INFO(node_->get_logger(), "HumanoidController activated");\n    }\n\n    void deactivate() override\n    {\n        RCLCPP_INFO(node_->get_logger(), "HumanoidController deactivated");\n    }\n\n    geometry_msgs::msg::Twist computeVelocityCommands(\n        const geometry_msgs::msg::PoseStamped & pose,\n        const geometry_msgs::msg::Twist & velocity,\n        nav2_core::GoalChecker * goal_checker) override\n    {\n        geometry_msgs::msg::Twist cmd_vel;\n\n        if (current_path_.poses.empty()) {\n            RCLCPP_WARN(node_->get_logger(), "No path received, stopping robot");\n            return cmd_vel;  // Return zero velocity\n        }\n\n        // Find closest point on path\n        size_t closest_idx = findClosestPoseIndex(pose, current_path_);\n\n        // Calculate desired velocity based on path\n        cmd_vel = calculatePathFollowingVelocity(pose, current_path_, closest_idx);\n\n        // Apply humanoid-specific constraints\n        cmd_vel = applyHumanoidConstraints(cmd_vel, pose);\n\n        // Check for obstacles in local costmap\n        if (isPathObstructed(pose, cmd_vel)) {\n            cmd_vel = handleObstacles(cmd_vel, pose);\n        }\n\n        return cmd_vel;\n    }\n\n    void setPlan(const nav_msgs::msg::Path & path) override\n    {\n        current_path_ = path;\n        RCLCPP_INFO(node_->get_logger(), "New plan set with %zu waypoints", path.poses.size());\n    }\n\nprivate:\n    size_t findClosestPoseIndex(\n        const geometry_msgs::msg::PoseStamped & pose,\n        const nav_msgs::msg::Path & path)\n    {\n        double min_dist = std::numeric_limits<double>::max();\n        size_t closest_idx = 0;\n\n        for (size_t i = 0; i < path.poses.size(); ++i) {\n            double dist = euclideanDistance(pose.pose.position, path.poses[i].pose.position);\n            if (dist < min_dist) {\n                min_dist = dist;\n                closest_idx = i;\n            }\n        }\n\n        return closest_idx;\n    }\n\n    geometry_msgs::msg::Twist calculatePathFollowingVelocity(\n        const geometry_msgs::msg::PoseStamped & pose,\n        const nav_msgs::msg::Path & path,\n        size_t closest_idx)\n    {\n        geometry_msgs::msg::Twist cmd_vel;\n\n        if (closest_idx >= path.poses.size() - 1) {\n            // At end of path, slow down\n            cmd_vel.linear.x = 0.0;\n            cmd_vel.angular.z = 0.0;\n            return cmd_vel;\n        }\n\n        // Calculate direction to follow path\n        auto target_pose = path.poses[std::min(closest_idx + 1, path.poses.size() - 1)];\n\n        // Calculate error to path\n        double dx = target_pose.pose.position.x - pose.pose.position.x;\n        double dy = target_pose.pose.position.y - pose.pose.position.y;\n\n        // Convert to robot frame\n        double yaw = tf2::getYaw(pose.pose.orientation);\n        double local_dx = dx * cos(yaw) + dy * sin(yaw);\n        double local_dy = -dx * sin(yaw) + dy * cos(yaw);\n\n        // PID-like control for path following\n        cmd_vel.linear.x = std::min(max_linear_speed_,\n                                   std::max(-max_linear_speed_, local_dx * linear_gain_));\n        cmd_vel.linear.y = std::min(max_linear_speed_,\n                                   std::max(-max_linear_speed_, local_dy * linear_gain_));\n        cmd_vel.angular.z = std::min(max_angular_speed_,\n                                    std::max(-max_angular_speed_, -local_dy * angular_gain_));\n\n        return cmd_vel;\n    }\n\n    geometry_msgs::msg::Twist applyHumanoidConstraints(\n        const geometry_msgs::msg::Twist & raw_cmd,\n        const geometry_msgs::msg::PoseStamped & pose)\n    {\n        geometry_msgs::msg::Twist constrained_cmd = raw_cmd;\n\n        // Apply humanoid-specific velocity limits\n        constrained_cmd.linear.x = std::clamp(constrained_cmd.linear.x,\n                                            -max_step_length_ * step_frequency_,\n                                            max_step_length_ * step_frequency_);\n        constrained_cmd.linear.y = std::clamp(constrained_cmd.linear.y,\n                                            -max_step_width_ * step_frequency_,\n                                            max_step_width_ * step_frequency_);\n        constrained_cmd.angular.z = std::clamp(constrained_cmd.angular.z,\n                                             -max_angular_velocity_,\n                                             max_angular_velocity_);\n\n        return constrained_cmd;\n    }\n\n    bool isPathObstructed(\n        const geometry_msgs::msg::PoseStamped & pose,\n        const geometry_msgs::msg::Twist & cmd_vel)\n    {\n        // Check costmap for obstacles in the robot\'s path\n        unsigned int mx, my;\n        if (!costmap_->worldToMap(pose.pose.position.x, pose.pose.position.y, mx, my)) {\n            return true;  // Robot position not in costmap\n        }\n\n        // Check ahead in the direction of movement\n        double ahead_x = pose.pose.position.x + cmd_vel.linear.x * 0.5;  // 0.5 seconds ahead\n        double ahead_y = pose.pose.position.y + cmd_vel.linear.y * 0.5;\n\n        unsigned int ahead_mx, ahead_my;\n        if (costmap_->worldToMap(ahead_x, ahead_y, ahead_mx, ahead_my)) {\n            unsigned char cost = costmap_->getCost(ahead_mx, ahead_my);\n            return cost > nav2_costmap_2d::INSCRIBED_INFLATED_OBSTACLE;\n        }\n\n        return false;\n    }\n\n    geometry_msgs::msg::Twist handleObstacles(\n        const geometry_msgs::msg::Twist & cmd_vel,\n        const geometry_msgs::msg::PoseStamped & pose)\n    {\n        // Implement humanoid-specific obstacle avoidance\n        geometry_msgs::msg::Twist avoidance_cmd = cmd_vel;\n\n        // For humanoid robots, we might need to step around obstacles\n        // rather than just turn\n        avoidance_cmd.linear.x = 0.0;  // Stop forward motion\n        avoidance_cmd.angular.z = 0.0;  // Stop turning\n\n        // Implement step-based obstacle avoidance\n        // This could involve planning discrete steps around obstacles\n        // which is more complex than simple velocity modification\n\n        return avoidance_cmd;\n    }\n\n    double euclideanDistance(const geometry_msgs::msg::Point & p1,\n                           const geometry_msgs::msg::Point & p2)\n    {\n        return sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));\n    }\n\n    // Member variables\n    rclcpp_lifecycle::LifecycleNode::SharedPtr node_;\n    std::string name_;\n    std::shared_ptr<tf2_ros::Buffer> tf_;\n    std::shared_ptr<nav2_costmap_2d::Costmap2DROS> costmap_ros_;\n    nav2_costmap_2d::Costmap2D * costmap_;\n    nav_msgs::msg::Path current_path_;\n\n    // Humanoid-specific parameters\n    double step_frequency_;\n    double max_step_length_;\n    double max_step_width_;\n    double balance_margin_;\n    double max_linear_speed_ = 0.5;\n    double max_angular_speed_ = 0.5;\n    double max_angular_velocity_ = 0.5;\n    double linear_gain_ = 1.0;\n    double angular_gain_ = 2.0;\n};\n'})}),"\n",(0,t.jsx)(e.h2,{id:"integration-with-isaac-sim",children:"Integration with Isaac Sim"}),"\n",(0,t.jsx)(e.h3,{id:"isaac-sim-navigation-setup",children:"Isaac Sim Navigation Setup"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'# Isaac Sim navigation integration\nimport omni\nfrom omni.isaac.core import World\nfrom omni.isaac.core.utils.stage import add_reference_to_stage\nfrom omni.isaac.core.robots import Robot\nfrom omni.isaac.core.utils.nucleus import get_assets_root_path\nimport carb\n\nclass IsaacSimNavigation:\n    def __init__(self):\n        self.world = World(stage_units_in_meters=1.0)\n        self.setup_scene()\n\n    def setup_scene(self):\n        # Add humanoid robot\n        assets_root_path = get_assets_root_path()\n        if assets_root_path is None:\n            carb.log_error("Could not find Isaac Sim assets. Please check your Isaac Sim installation.")\n            return\n\n        # Add a humanoid robot to the scene\n        humanoid_asset_path = assets_root_path + "/Isaac/Robots/Humanoid/humanoid.usd"\n        add_reference_to_stage(usd_path=humanoid_asset_path, prim_path="/World/Humanoid")\n\n        # Add a simple environment\n        room_asset_path = assets_root_path + "/Isaac/Environments/Simple_Room/simple_room.usd"\n        add_reference_to_stage(usd_path=room_asset_path, prim_path="/World/Room")\n\n        # Initialize the world\n        self.world.reset()\n\n    def setup_navigation(self):\n        # Configure navigation-specific components\n        # This would include setting up sensors, costmaps, etc.\n        pass\n\n    def run_navigation(self, goal_position):\n        # Main navigation loop\n        while not self.world.is_stopped():\n            self.world.step(render=True)\n\n            # Get robot position\n            robot_position = self.get_robot_position()\n\n            # Check if reached goal\n            if self.is_at_goal(robot_position, goal_position):\n                print("Reached goal!")\n                break\n\n            # Continue navigation\n            self.navigate_to_goal(goal_position)\n\n    def get_robot_position(self):\n        # Get current robot position from Isaac Sim\n        pass\n\n    def navigate_to_goal(self, goal_position):\n        # Send navigation commands to robot\n        pass\n\n    def is_at_goal(self, current_pos, goal_pos):\n        # Check if robot is at goal position\n        distance = ((current_pos[0] - goal_pos[0])**2 +\n                   (current_pos[1] - goal_pos[1])**2)**0.5\n        return distance < 0.2  # 20cm tolerance\n'})}),"\n",(0,t.jsx)(e.h2,{id:"performance-evaluation",children:"Performance Evaluation"}),"\n",(0,t.jsx)(e.h3,{id:"navigation-metrics-for-humanoid-robots",children:"Navigation Metrics for Humanoid Robots"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"// Navigation performance evaluation\nclass NavigationEvaluator\n{\npublic:\n    struct NavigationMetrics\n    {\n        double success_rate;\n        double average_time_to_goal;\n        double path_efficiency;  // actual_path_length / optimal_path_length\n        double collision_count;\n        double balance_loss_count;\n        double step_success_rate;\n    };\n\n    NavigationMetrics evaluateNavigation(\n        const std::vector<geometry_msgs::msg::Pose>& trajectory,\n        const geometry_msgs::msg::Pose& goal,\n        bool navigation_successful)\n    {\n        NavigationMetrics metrics;\n\n        // Calculate success rate\n        metrics.success_rate = navigation_successful ? 1.0 : 0.0;\n\n        // Calculate path efficiency\n        double actual_path_length = calculatePathLength(trajectory);\n        double optimal_path_length = calculateEuclideanDistance(trajectory.front().position, goal.position);\n        metrics.path_efficiency = optimal_path_length > 0 ? actual_path_length / optimal_path_length : 1.0;\n\n        // Count collisions (high cost areas in trajectory)\n        metrics.collision_count = countCollisions(trajectory);\n\n        // Count balance losses (if available)\n        metrics.balance_loss_count = countBalanceLosses(trajectory);\n\n        return metrics;\n    }\n\nprivate:\n    double calculatePathLength(const std::vector<geometry_msgs::msg::Pose>& trajectory)\n    {\n        double length = 0.0;\n        for (size_t i = 1; i < trajectory.size(); ++i) {\n            length += calculateEuclideanDistance(\n                trajectory[i-1].position,\n                trajectory[i].position\n            );\n        }\n        return length;\n    }\n\n    double calculateEuclideanDistance(\n        const geometry_msgs::msg::Point& p1,\n        const geometry_msgs::msg::Point& p2)\n    {\n        return sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));\n    }\n\n    int countCollisions(const std::vector<geometry_msgs::msg::Pose>& trajectory)\n    {\n        // Count poses in high-cost areas of costmap\n        int collision_count = 0;\n        // Implementation would check each pose against costmap\n        return collision_count;\n    }\n\n    int countBalanceLosses(const std::vector<geometry_msgs::msg::Pose>& trajectory)\n    {\n        // Count instances where robot lost balance\n        // This would require access to balance metrics\n        return 0;\n    }\n};\n"})}),"\n",(0,t.jsx)(e.h2,{id:"troubleshooting-navigation-issues",children:"Troubleshooting Navigation Issues"}),"\n",(0,t.jsx)(e.h3,{id:"common-problems-and-solutions",children:"Common Problems and Solutions"}),"\n",(0,t.jsx)(e.h4,{id:"1-robot-gets-stuck",children:"1. Robot Gets Stuck"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem"}),": Robot stops moving or oscillates in place\n",(0,t.jsx)(e.strong,{children:"Solutions"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Check costmap inflation settings"}),"\n",(0,t.jsx)(e.li,{children:"Verify sensor data is being received"}),"\n",(0,t.jsx)(e.li,{children:"Adjust local planner parameters"}),"\n",(0,t.jsx)(e.li,{children:"Implement proper recovery behaviors"}),"\n"]}),"\n",(0,t.jsx)(e.h4,{id:"2-poor-path-quality",children:"2. Poor Path Quality"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem"}),": Robot takes inefficient or unsafe paths\n",(0,t.jsx)(e.strong,{children:"Solutions"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Tune global planner parameters"}),"\n",(0,t.jsx)(e.li,{children:"Adjust costmap resolution"}),"\n",(0,t.jsx)(e.li,{children:"Verify map quality and accuracy"}),"\n",(0,t.jsx)(e.li,{children:"Check for proper obstacle detection"}),"\n"]}),"\n",(0,t.jsx)(e.h4,{id:"3-balance-issues-during-navigation",children:"3. Balance Issues During Navigation"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Problem"}),": Humanoid robot loses balance while following path\n",(0,t.jsx)(e.strong,{children:"Solutions"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Implement step-by-step planning"}),"\n",(0,t.jsx)(e.li,{children:"Add balance controller"}),"\n",(0,t.jsx)(e.li,{children:"Reduce navigation speed"}),"\n",(0,t.jsx)(e.li,{children:"Improve path smoothing"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(e.h3,{id:"1-parameter-tuning",children:"1. Parameter Tuning"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Start with conservative parameters"}),"\n",(0,t.jsx)(e.li,{children:"Test in simulation before real robot"}),"\n",(0,t.jsx)(e.li,{children:"Use systematic parameter tuning methods"}),"\n",(0,t.jsx)(e.li,{children:"Document parameter sets for different environments"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"2-safety-considerations",children:"2. Safety Considerations"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Implement emergency stops"}),"\n",(0,t.jsx)(e.li,{children:"Monitor robot state continuously"}),"\n",(0,t.jsx)(e.li,{children:"Set appropriate velocity limits"}),"\n",(0,t.jsx)(e.li,{children:"Use proper collision checking"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"3-performance-optimization",children:"3. Performance Optimization"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Use appropriate costmap resolution"}),"\n",(0,t.jsx)(e.li,{children:"Optimize sensor update rates"}),"\n",(0,t.jsx)(e.li,{children:"Implement efficient path planning"}),"\n",(0,t.jsx)(e.li,{children:"Monitor computational resources"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"exercise",children:"Exercise"}),"\n",(0,t.jsx)(e.p,{children:"Create a complete navigation system for a humanoid robot that includes:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Custom Nav2 configuration optimized for humanoid locomotion"}),"\n",(0,t.jsx)(e.li,{children:"A step planner that generates discrete foot placements"}),"\n",(0,t.jsx)(e.li,{children:"A balance controller to maintain stability during navigation"}),"\n",(0,t.jsx)(e.li,{children:"Integration with Isaac Sim for testing"}),"\n",(0,t.jsx)(e.li,{children:"Performance evaluation tools to measure navigation success"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"Test your system in various scenarios including:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Indoor navigation with furniture"}),"\n",(0,t.jsx)(e.li,{children:"Narrow passages"}),"\n",(0,t.jsx)(e.li,{children:"Obstacle avoidance"}),"\n",(0,t.jsx)(e.li,{children:"Stair navigation (if applicable)"}),"\n",(0,t.jsx)(e.li,{children:"Dynamic obstacle avoidance"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"Evaluate the system's performance using the metrics discussed in this section."})]})}function d(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(_,{...n})}):_(n)}},8453:(n,e,o)=>{o.d(e,{R:()=>s,x:()=>r});var a=o(6540);const t={},i=a.createContext(t);function s(n){const e=a.useContext(i);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:s(n.components),a.createElement(i.Provider,{value:e},n.children)}}}]);